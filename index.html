<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>CEHM æ˜Ÿé˜µ (æé€Ÿè§¦æ§ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: sans-serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .ui-hidden { opacity: 0; pointer-events: none !important; }

        /* åŠ è½½åŠ¨ç”» (åªåœ¨æœ€å¼€å§‹æ˜¾ç¤ºä¸€ä¸‹) */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s ease-out; 
        }
        .spinner {
            width: 40px; height: 40px; 
            border: 3px solid rgba(75, 156, 211, 0.2); 
            border-top: 3px solid #4B9CD3; border-radius: 50%; 
            animation: spin 0.8s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .loader-text { color: #4B9CD3; font-size: 14px; letter-spacing: 2px; }

        /* é¡¶éƒ¨æç¤ºæ¡ (æ›¿ä»£å¤æ‚çš„æ—¥å¿—) */
        #status-bar {
            position: absolute; top: 0; left: 0; width: 100%; 
            background: rgba(0, 20, 40, 0.8); color: #88ccff;
            font-size: 12px; text-align: center; padding: 5px 0;
            z-index: 20; pointer-events: none;
        }

        /* æŒ‰é’® */
        .controls-container {
            position: absolute; top: 40px; right: 10px; pointer-events: auto;
            text-align: right; transform: scale(0.9); transform-origin: top right;
        }
        .btn {
            background: rgba(0, 30, 60, 0.8); border: 1px solid rgba(75, 156, 211, 0.5); 
            color: #aaddff; padding: 8px 15px; cursor: pointer; border-radius: 4px; font-size: 12px;
            margin-bottom: 10px; display: block;
        }

        /* å¼¹çª— */
        #manager-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 85%; max-width: 400px; max-height: 70vh; background: rgba(5, 15, 25, 0.95);
            border: 1px solid #4B9CD3; border-radius: 10px; padding: 15px; display: flex; flex-direction: column;
            pointer-events: auto; color: #fff; transition: opacity 0.3s;
        }
        #manager-modal.hidden { opacity: 0; pointer-events: none; }
        
        .card-list { flex: 1; overflow-y: auto; margin: 10px 0; min-height: 100px; border: 1px solid #333; padding: 5px;}
        .card-item { background: rgba(255,255,255,0.1); margin-bottom: 5px; padding: 8px; font-size: 12px; display:flex; justify-content:space-between;}
        .card-item.drawn { text-decoration: line-through; opacity: 0.5; color: #888; }
        
        .add-form { display: flex; gap: 5px; }
        .modal-input { background: #111; border: 1px solid #555; color: white; padding: 5px; flex: 1; outline:none;}

        /* åº•éƒ¨æ“ä½œæç¤º */
        .bottom-hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #fff; font-size: 16px; pointer-events: none; font-weight: bold;
            text-shadow: 0 0 10px #4B9CD3; padding: 0 20px; box-sizing: border-box;
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; } 100% { opacity: 0.8; } }

        /* æ‘„åƒå¤´å°çª— (é»˜è®¤éšè—ï¼ŒæˆåŠŸæ‰æ˜¾ç¤º) */
        #webcam-wrapper {
            position: absolute; bottom: 80px; right: 10px; width: 80px; height: 60px;
            border: 1px solid #4B9CD3; opacity: 0.6; pointer-events: none; 
            background: #000; border-radius: 5px; overflow: hidden; display: none;
        }
        #webcam-preview { width: 100%; height: 100%; transform: scaleX(-1); }
    </style>
    
    <!-- æé€Ÿ CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://npm.elemecdn.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://npm.elemecdn.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://npm.elemecdn.com/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">æ˜Ÿé˜µå¯åŠ¨ä¸­...</div>
    </div>

    <div id="status-bar">æ­£åœ¨å°è¯•è¿æ¥æ‘„åƒå¤´... (æ‚¨å¯ä»¥ç›´æ¥ç‚¹å‡»å±å¹•æ“ä½œ)</div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="controls-container">
            <button id="open-manager-btn" class="btn">âš™ï¸ ç®¡ç†ç­¾æ–‡</button>
            <button id="toggle-cam-btn" class="btn" style="display:none;">ğŸ“· å¼€/å…³æ‘„åƒå¤´</button>
        </div>

        <div id="manager-modal" class="hidden">
            <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
                <span style="color:#4B9CD3; font-weight:bold;">å¤©æœºå†Œ</span>
                <span id="close-manager-btn" style="cursor:pointer; color:red; padding:0 10px; font-size:20px;">Ã—</span>
            </div>
            <div class="add-form">
                <input id="mgr-text" class="modal-input" placeholder="è¾“å…¥ç¥ç¦è¯­">
                <button id="mgr-add-btn" class="btn" style="margin:0;">æ·»åŠ </button>
            </div>
            <div class="card-list" id="card-list-container"></div>
            <div style="text-align:center;">
                <button id="mgr-reset-btn" class="btn" style="width:100%; margin-top:5px;">é‡ç½®æ‰€æœ‰</button>
            </div>
        </div>

        <div class="bottom-hint" id="main-hint">ğŸ‘† ç‚¹å‡»å±å¹• æ¿€æ´»æ˜Ÿé˜µ</div>
    </div>

    <div id="webcam-wrapper">
        <canvas id="webcam-preview"></canvas>
        <video id="webcam" autoplay playsinline style="display:none;"></video>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- çŠ¶æ€ä¸æ•°æ® ---
        let fortuneDatabase = [
            { id: 1, text: "ä¸‡äº‹èƒœæ„", signature: "å¹¸è¿æ˜Ÿ", isDrawn: false },
            { id: 2, text: "æœªæ¥å¯æœŸ", signature: "æ–‡æ›²æ˜Ÿ", isDrawn: false },
            { id: 3, text: "ç™¾ç—…ä¸ä¾µ", signature: "å®ˆæŠ¤ç¥", isDrawn: false },
            { id: 4, text: "å¹³å®‰å–œä¹", signature: "ç¦æ˜Ÿ", isDrawn: false },
            { id: 5, text: "ç¾æ¢¦æˆçœŸ", signature: "è®¸æ„¿æ± ", isDrawn: false },
            { id: 6, text: "æ—¥è¿›æ–—é‡‘", signature: "è´¢ç¥", isDrawn: false },
            { id: 7, text: "é”¦é²¤é™„ä½“", signature: "å¥½è¿", isDrawn: false },
            { id: 8, text: "å¤§å‰å¤§åˆ©", signature: "ä¸Šä¸Šç­¾", isDrawn: false }
        ];

        const CONFIG = { colors: { bg: 0x000000 }, particles: 3500 };
        const STATE = { mode: 'LOGO', focusTarget: null, readyToDraw: false, rotation: { x: 0, y: 0 } };

        let scene, camera, renderer, composer, mainGroup, clock = new THREE.Clock();
        let particleSystem = [], stripMeshGroup = new THREE.Group();
        let handLandmarker, video, webcamCanvas, webcamCtx;
        let logoPoints = []; 

        // --- æ ¸å¿ƒåˆå§‹åŒ– (ä¿è¯ç”»é¢å…ˆå‡ºæ¥) ---
        function init() {
            // 1. å…ˆæå®š3Dç”»é¢
            generateLogoPoints();
            initThree();
            createObjects();
            setupPostProcessing();
            refreshStrips();
            animate();
            setupUI();
            
            // 2. ç§»é™¤åŠ è½½é®ç½© (ç«‹åˆ»æ˜¾ç¤ºç”»é¢ï¼Œä¸ç®¡AIå¥½æ²¡å¥½)
            setTimeout(() => {
                const l = document.getElementById('loader');
                if(l) { l.style.opacity = 0; setTimeout(()=>l.remove(), 500); }
            }, 800);

            // 3. ç»‘å®šç‚¹å‡»äº¤äº’ (è¿™æ˜¯ä¿åº•æ–¹æ¡ˆ)
            setupTouchInteraction();

            // 4. åå°æ‚„æ‚„åŠ è½½AI (å¦‚æœå¤±è´¥äº†ä¹Ÿä¸å½±å“ç©)
            initAI().catch(err => {
                console.log("AIåŠ è½½å¤±è´¥ï¼Œåˆ‡æ¢çº¯è§¦æ§æ¨¡å¼", err);
                document.getElementById('status-bar').innerText = "âš ï¸ æ‘„åƒå¤´æœªå°±ç»ªï¼Œè¯·ç›´æ¥ä½¿ç”¨æ‰‹æŒ‡ç‚¹å‡»å±å¹•";
                setTimeout(() => document.getElementById('status-bar').style.opacity = 0, 5000);
            });

            setupEvents();
        }

        // --- 3D åœºæ™¯æ„å»º ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.002);
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 75);
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            mainGroup = new THREE.Group(); scene.add(mainGroup);
            
            scene.add(new THREE.AmbientLight(0x404040));
            const light = new THREE.DirectionalLight(0xffffff, 1); light.position.set(10, 10, 10); scene.add(light);
            mainGroup.add(new THREE.PointLight(0x4B9CD3, 2, 50));
        }

        function createObjects() {
            // ç®€å•çš„æ˜Ÿç©º
            const sGeo = new THREE.BufferGeometry();
            const sPos = [];
            for(let i=0; i<1000; i++) {
                const r = 200 + Math.random()*300;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2*Math.random()-1);
                sPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
            }
            sGeo.setAttribute('position', new THREE.Float32BufferAttribute(sPos, 3));
            scene.add(new THREE.Points(sGeo, new THREE.PointsMaterial({color:0x888888, size:1.0})));

            // ç²’å­
            const geo = new THREE.TetrahedronGeometry(0.2, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0x4B9CD3, wireframe: true });
            for(let i=0; i<CONFIG.particles; i++) {
                let tp = logoPoints.length ? logoPoints[i%logoPoints.length] : {x:(Math.random()-.5)*50, y:(Math.random()-.5)*50, z:0};
                const m = new THREE.Mesh(geo, mat);
                m.rotation.set(Math.random()*3, Math.random()*3, 0);
                mainGroup.add(m);
                particleSystem.push(new Particle(m, tp));
            }
            mainGroup.add(stripMeshGroup);
        }

        class Particle {
            constructor(mesh, tp) {
                this.mesh = mesh; this.type = tp.type; this.dbId = tp.dbId;
                this.posLogo = new THREE.Vector3(tp.x, tp.y, tp.z);
                this.posScatter = new THREE.Vector3((Math.random()-.5)*100, (Math.random()-.5)*100, (Math.random()-.5)*50);
                this.mesh.position.copy(this.posScatter);
            }
            update(dt, mode, target) {
                let dest = (mode === 'LOGO') ? this.posLogo : this.posScatter;
                let s = 1;
                let speed = 3;
                
                if (mode === 'FOCUS' && this.mesh === target) {
                    dest = new THREE.Vector3(0, 0, 40).applyMatrix4(mainGroup.matrixWorld.clone().invert());
                    s = 4;
                    speed = 2;
                    this.mesh.lookAt(camera.position.clone().applyMatrix4(mainGroup.matrixWorld.clone().invert()));
                    // åªæœ‰è¢«é€‰ä¸­çš„å¡ç‰‡ä¼šå‘å…‰
                     if(this.mesh.children[0]) this.mesh.children[0].material.color.setHex(0xffffff);
                } else {
                     if(this.type === 'STRIP' && this.mesh.children[0]) this.mesh.children[0].material.color.setHex(0x4B9CD3);
                }
                
                this.mesh.position.lerp(dest, speed * dt);
                this.mesh.scale.lerp(new THREE.Vector3(s, s, s), speed * dt);
                this.mesh.rotation.x += dt;
            }
        }

        // --- è§¦æ§/é¼ æ ‡äº¤äº’ (æœ€å¯é çš„ç©æ³•) ---
        function setupTouchInteraction() {
            const hint = document.getElementById('main-hint');
            
            document.body.addEventListener('click', (e) => {
                // å¦‚æœç‚¹çš„æ˜¯UIæŒ‰é’®ï¼Œä¸è§¦å‘åœºæ™¯äº¤äº’
                if(e.target.closest('.btn') || e.target.closest('#manager-modal') || e.target.closest('.add-form')) return;

                if (STATE.mode === 'LOGO') {
                    // 1. æ¿€æ´»
                    STATE.mode = 'SCATTER'; STATE.readyToDraw = true;
                    hint.innerText = "âœ¨ å·²æ¿€æ´»ï¼å†æ¬¡ç‚¹å‡»æŠ½å– âœ¨";
                } else if (STATE.readyToDraw && STATE.mode !== 'FOCUS') {
                    // 2. æŠ½ç­¾
                    hint.innerText = "ğŸ‰ æ­£åœ¨æŠ½å–...";
                    const pool = particleSystem.filter(p => p.type === 'STRIP' && !fortuneDatabase.find(c => c.id === p.dbId).isDrawn);
                    
                    if (pool.length > 0) {
                        const p = pool[Math.floor(Math.random() * pool.length)];
                        p.isDrawn = true;
                        fortuneDatabase.find(c => c.id === p.dbId).isDrawn = true;
                        STATE.focusTarget = p.mesh;
                        STATE.mode = 'FOCUS';
                        hint.innerText = "ğŸ‘† ç‚¹å‡»å±å¹• è¿”å›æ˜Ÿç©º";
                    } else {
                        hint.innerText = "ç­¾ç­’å·²ç©º (è¯·åœ¨ç®¡ç†ä¸­é‡ç½®)";
                    }
                } else if (STATE.mode === 'FOCUS') {
                    // 3. é‡ç½®
                    STATE.mode = 'LOGO'; STATE.focusTarget = null; STATE.readyToDraw = false;
                    hint.innerText = "ğŸ‘† ç‚¹å‡»å±å¹• æ¿€æ´»æ˜Ÿé˜µ";
                }
            });
        }

        // --- AI åŠ è½½ (ä¸é˜»å¡ä¸»çº¿ç¨‹) ---
        async function initAI() {
            video = document.getElementById('webcam');
            webcamCanvas = document.getElementById('webcam-preview');
            webcamCtx = webcamCanvas.getContext('2d');
            webcamCanvas.width = 120; webcamCanvas.height = 90;

            // å°è¯•å›½å†…æº
            const wasmUrl = "https://npm.elemecdn.com/@mediapipe/tasks-vision@0.10.3/wasm";
            const modelUrl = "https://npm.elemecdn.com/@mediapipe/tasks-vision@0.10.3/wasm/hand_landmarker.task"; // å°è¯•ç›´æ¥ç”¨åŒ…é‡Œçš„taskï¼Œå¦‚æœå¤±è´¥åˆ™å›é€€

            const vision = await FilesetResolver.forVisionTasks(wasmUrl);
            try {
                // å…ˆå°è¯•å®˜æ–¹CDN
                 handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
            } catch(e) {
                console.log("å®˜æ–¹æºå¤±è´¥ï¼Œå°è¯•å¤‡ç”¨æº");
                // å¤‡ç”¨ï¼šä¸åŠ è½½æ¨¡å‹ï¼Œä»…è§¦æ§
                throw new Error("æ¨¡å‹ä¸‹è½½è¶…æ—¶");
            }

            if (!navigator.mediaDevices?.getUserMedia) throw new Error("æ— æ‘„åƒå¤´æƒé™");
            
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } });
            video.srcObject = stream;
            video.addEventListener("loadeddata", () => {
                document.getElementById('webcam-wrapper').style.display = 'block';
                document.getElementById('status-bar').innerText = "ğŸ“· æ‘„åƒå¤´å·²è¿æ¥ | æ”¯æŒæ‰‹åŠ¿ & è§¦æ§";
                predictWebcam();
            });
        }

        async function predictWebcam() {
            if (handLandmarker && video.currentTime > 0) {
                try {
                    const res = handLandmarker.detectForVideo(video, performance.now());
                    webcamCtx.clearRect(0,0,120,90);
                    if(res.landmarks && res.landmarks.length) {
                        const lm = res.landmarks[0];
                        drawSkeleton(webcamCtx, lm);
                        // ç®€å•æ‰‹åŠ¿é€»è¾‘
                        const d = (i,j) => Math.hypot(lm[i].x-lm[j].x, lm[i].y-lm[j].y);
                        const open = d(9,0);
                        const pinch = d(4,8);
                        
                        if (open < 0.2) document.body.click(); // ç®€å•æ˜ å°„ï¼šæ¡æ‹³æˆ–åŠ¨ä½œå¤§å˜åŒ–è§¦å‘ç‚¹å‡»é€»è¾‘
                    }
                } catch(e){}
            }
            requestAnimationFrame(predictWebcam);
        }
        
        function drawSkeleton(ctx, lm) {
            ctx.strokeStyle='#00ffff'; ctx.lineWidth=2; ctx.beginPath();
            const idx = [0,1,2,3,4,0,5,6,7,8,0,9,10,11,12,0,13,14,15,16,0,17,18,19,20];
            for(let i=0; i<idx.length-1; i++) {
                ctx.moveTo(lm[idx[i]].x*120, lm[idx[i]].y*90);
                ctx.lineTo(lm[idx[i+1]].x*120, lm[idx[i+1]].y*90);
            }
            ctx.stroke();
        }

        // --- è¾…åŠ©å‡½æ•° ---
        function generateLogoPoints() {
            for(let i=0; i<1500; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 15 + Math.random() * 5;
                logoPoints.push({x: Math.cos(angle)*r, y: Math.sin(angle)*r, z: (Math.random()-.5)*2, type: 'BLUE'});
            }
        }

        function createStripTexture(txt, sig) {
            const c = document.createElement('canvas'); c.width=256; c.height=400;
            const x = c.getContext('2d');
            x.fillStyle = '#001a33'; x.fillRect(0,0,256,400);
            x.strokeStyle = '#4B9CD3'; x.lineWidth=5; x.strokeRect(5,5,246,390);
            x.fillStyle = 'white'; x.font = 'bold 30px sans-serif'; x.textAlign='center';
            x.fillText(txt.substring(0,6), 128, 180);
            if(txt.length>6) x.fillText(txt.substring(6), 128, 220);
            x.font = '16px sans-serif'; x.fillStyle = '#aaa'; x.fillText(sig, 128, 350);
            const t = new THREE.CanvasTexture(c); t.colorSpace = THREE.SRGBColorSpace;
            return t;
        }

        function refreshStrips() {
            stripMeshGroup.clear();
            particleSystem = particleSystem.filter(p => p.type !== 'STRIP');
            fortuneDatabase.forEach(item => {
                const tex = createStripTexture(item.text, item.signature);
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 3), new THREE.MeshBasicMaterial({map: tex}));
                // è¾¹æ¡†
                const frame = new THREE.Mesh(new THREE.BoxGeometry(2.1, 3.1, 0.1), new THREE.MeshBasicMaterial({color:0x4B9CD3}));
                frame.position.z = -0.1;
                mesh.add(frame);
                
                stripMeshGroup.add(mesh);
                particleSystem.push(new Particle(mesh, {x:0, y:0, z:0, type:'STRIP', dbId: item.id}));
            });
        }

        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.85));
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setupUI() {
            const list = document.getElementById('card-list-container');
            const updateList = () => {
                list.innerHTML = '';
                fortuneDatabase.forEach(f => {
                    list.innerHTML += `<div class="card-item ${f.isDrawn?'drawn':''}"><span>${f.text}</span><span>${f.isDrawn?'å·²æŠ½':'æœª'}</span></div>`;
                });
            }
            document.getElementById('open-manager-btn').onclick = () => { document.getElementById('manager-modal').classList.remove('hidden'); updateList(); };
            document.getElementById('close-manager-btn').onclick = () => document.getElementById('manager-modal').classList.add('hidden');
            
            document.getElementById('mgr-add-btn').onclick = () => {
                const val = document.getElementById('mgr-text').value;
                if(val) { fortuneDatabase.push({id:Date.now(), text:val, signature:'è‡ªå®š', isDrawn:false}); document.getElementById('mgr-text').value=''; updateList(); refreshStrips(); }
            };
            document.getElementById('mgr-reset-btn').onclick = () => {
                fortuneDatabase.forEach(f => f.isDrawn=false); updateList(); refreshStrips();
            };
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            mainGroup.rotation.y += 0.1 * dt;
            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
            composer.render();
        }

        init();
    </script>
</body>
</html>
