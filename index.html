<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CEHM Cosmic Fortune Draw</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Times New Roman', serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
        }
        
        .ui-hidden { opacity: 0; pointer-events: none !important; }
        /* Loading */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #010205; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1.5s ease-out; 
        }
        .loader-text {
            color: #4B9CD3; /* æ”¹ä¸º Logo è“ */
            font-size: 16px; letter-spacing: 8px; margin-top: 20px;
            text-transform: uppercase; font-weight: 300;
            text-shadow: 0 0 15px rgba(75, 156, 211, 0.8);
            font-family: "Microsoft YaHei", serif;
        }
        .spinner {
            width: 50px; height: 50px; 
            border: 2px solid rgba(75, 156, 211, 0.2); 
            border-top: 2px solid #4B9CD3; border-radius: 50%; 
            animation: spin 1.5s linear infinite; 
            box-shadow: 0 0 20px rgba(75, 156, 211, 0.4);
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Controls Container - Top Right & Scaled Down */
        .controls-container {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: auto;
            text-align: right;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
            transition: opacity 0.5s ease;
            background: rgba(0, 20, 40, 0.6); 
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(75, 156, 211, 0.3);
            backdrop-filter: blur(8px);
            transform: scale(0.9);
            transform-origin: top right;
        }
        /* Buttons */
        .btn {
            background: rgba(0, 30, 60, 0.8); 
            border: 1px solid rgba(75, 156, 211, 0.5); 
            color: #aaddff; 
            padding: 6px 15px; 
            cursor: pointer; 
            text-transform: uppercase; 
            letter-spacing: 1px; 
            font-size: 11px;
            transition: all 0.4s;
            border-radius: 4px; 
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            min-width: 80px;
        }
        .btn:hover { 
            background: #4B9CD3; 
            color: #fff; 
            border-color: #aaddff;
            box-shadow: 0 0 20px rgba(75, 156, 211, 0.6);
        }
        .btn-gold {
            border-color: #4B9CD3;
            color: #4B9CD3;
        }
        .btn-gold:hover {
            background: #4B9CD3;
            color: #000;
            box-shadow: 0 0 20px rgba(75, 156, 211, 0.6);
        }
        .btn-icon {
            font-size: 16px;
            padding: 6px 10px;
            min-width: unset;
        }
        /* Manager Modal */
        #manager-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; max-width: 500px;
            max-height: 80vh;
            background: rgba(5, 15, 25, 0.95);
            border: 1px solid #4B9CD3;
            box-shadow: 0 0 50px rgba(0, 50, 100, 0.8);
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            pointer-events: auto;
            backdrop-filter: blur(15px);
            z-index: 1000;
            color: #fff;
            transition: opacity 0.3s;
        }
        #manager-modal.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 1px solid rgba(75, 156, 211, 0.3);
            padding-bottom: 10px; margin-bottom: 15px;
        }
        .modal-title { font-family: "Microsoft YaHei"; font-weight: bold; color: #4B9CD3; letter-spacing: 2px; }
        .modal-close { cursor: pointer; color: #ff5555; font-size: 20px; }
        
        .card-list {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding-right: 5px;
        }
        /* Scrollbar styling */
        .card-list::-webkit-scrollbar { width: 6px; }
        .card-list::-webkit-scrollbar-thumb { background: #003366; border-radius: 3px; }
        
        .card-item {
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 8px;
            padding: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 3px solid #555;
        }
        .card-item.drawn {
            opacity: 0.5;
            border-left-color: #333;
            text-decoration: line-through;
        }
        .card-item.active {
            border-left-color: #4B9CD3;
            background: rgba(75, 156, 211, 0.1);
        }
        .card-info { display: flex; flex-direction: column; gap: 2px; }
        .card-text { font-size: 14px; color: #fff; font-weight: bold; }
        .card-sig { font-size: 11px; color: #aaa; }
        .delete-btn { color: #ff5555; cursor: pointer; padding: 5px; font-size: 18px; margin-left: 5px; }
        .delete-btn:hover { color: #ff0000; }
        
        /* New Reset Button Style */
        .reset-btn { color: #00ffff; cursor: pointer; padding: 5px; font-size: 16px; margin-left: 10px; font-weight: bold;}
        .reset-btn:hover { color: #88ffff; text-shadow: 0 0 5px #00ffff; }
        .add-form {
            display: flex; gap: 8px; margin-bottom: 15px;
        }
        .modal-input {
            background: rgba(0,0,0,0.5); border: 1px solid #555;
            color: white; padding: 8px; flex: 1; border-radius: 4px;
            outline: none;
        }
        .modal-input:focus { border-color: #4B9CD3; }
        /* Separated Hint Text - Bottom Center */
        .bottom-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(200, 230, 255, 0.5);
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            pointer-events: none;
            text-align: center;
            width: 100%;
            font-weight: bold;
            font-family: "Microsoft YaHei";
            transition: color 0.3s;
        }
        /* Webcam feedback */
        #webcam-wrapper {
            position: absolute; bottom: 60px; right: 20px;
            width: 140px; height: 105px;
            border: 1px solid rgba(75, 156, 211, 0.3);
            overflow: hidden; 
            opacity: 0.7; 
            pointer-events: none;
            background: rgba(0, 10, 20, 0.6);
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 100, 200, 0.1);
            border-radius: 8px;
        }
        
        #webcam-preview {
            width: 100%; height: 100%;
            transform: scaleX(-1); 
        }
        
        @media (max-width: 600px) {
            .controls-container { top: 10px; right: 10px; transform: scale(0.8); }
            #webcam-wrapper { bottom: 20px; right: 10px; width: 100px; height: 75px; }
            .bottom-hint { font-size: 12px; bottom: 20px; }
        }
    </style>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
    </style>
    <!-- å›½å†… CDN å¤‡ç”¨æ–¹æ¡ˆ -->
    <script>
        // å¦‚æœ googleapis æ— æ³•è®¿é—®ï¼Œä½¿ç”¨å¤‡ç”¨ CDN
        window.CDN_CONFIG = {
            primary: {
                three: 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js',
                threeAddons: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/',
                mediapipe: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm'
            },
            backup: {
                // å›½å†…é•œåƒå¤‡é€‰æ–¹æ¡ˆ
                three: 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js',
                threeAddons: 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/',
                // mediapipe ä½¿ç”¨æœ¬åœ°æ¨¡å¼
                mediapipe: null // å°†ä½¿ç”¨ç®€åŒ–çš„æ‰‹åŠ¿è¯†åˆ«
            }
        };
        
        // æ£€æµ‹ç½‘ç»œè¿æ¥
        window.useBackupCDN = function() {
            // æµ‹è¯•ä¸» CDN æ˜¯å¦å¯ç”¨
            return fetch('https://cdn.jsdelivr.net/', { method: 'HEAD' })
                .then(() => false)
                .catch(() => true);
        };
    </script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>
    <div id="loader">
        <div class="spinner"></div>
        <div class="loader-text">ç¥ˆç¦æ˜Ÿé˜µéƒ¨ç½²ä¸­...</div>
    </div>
    <div id="canvas-container"></div>
    <div id="ui-layer">
        
        <!-- Top Right Controls -->
        <div class="controls-container">
            <button id="open-manager-btn" class="btn btn-gold">
                   âš™   ï¸ å¤©æœºå†Œ (ç®¡ç†å¡ç‰‡)
            </button>
        </div>
        <!-- Manager Modal (Hidden by default) -->
        <div id="manager-modal" class="hidden">
            <div class="modal-header">
                <div class="modal-title">å¤©æœºå†Œ - ç¬¦ç­¾ç®¡ç†</div>
                <div class="modal-close" id="close-manager-btn">Ã—</div>
            </div>
            
            <div class="add-form">
                <input type="text" id="mgr-text" class="modal-input" placeholder="è¾“å…¥ç¥ç¦è¯­">
                <input type="text" id="mgr-sig" class="modal-input" placeholder="ç½²å" style="flex:0.4">
                <button id="mgr-add-btn" class="btn btn-gold">æ·»åŠ </button>
            </div>
            <div class="card-list" id="card-list-container">
                <!-- Cards will be injected here -->
            </div>
            <div style="text-align: center; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px;">
                <button id="mgr-reset-btn" class="btn">é‡ç½®æ‰€æœ‰çŠ¶æ€</button>
                <div style="font-size: 10px; color: #666; margin-top: 5px;">å…± <span id="card-count">0</span> å¼ ï¼Œå·²æŠ½ <span id="drawn-count">0</span> å¼ </div>
            </div>
        </div>
        <!-- Bottom Center Hint -->
        <div class="bottom-hint">
            æµç¨‹: æ¡æ‹³é‡ç½® â†’ å¼ å¼€æ‰‹æŒæ¿€æ´» â†’ OKæ‰‹åŠ¿æŠ½å–<br>
            <span style="font-size:10px; opacity:0.7;">(æç¤ºï¼šå¦‚Logoæœªæ˜¾ç¤ºï¼Œè¯·ç›´æ¥å°†å›¾ç‰‡æ‹–å…¥çª—å£)</span>
        </div>
    </div>
    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline style="display:none;"></video>
        <canvas id="webcam-preview"></canvas>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        // --- DATA MANAGEMENT WITH LOCAL STORAGE ---
        let fortuneDatabase = [
            { id: 1, text: "ä¸‡äº‹èƒœæ„", signature: "å¹¸è¿æ˜Ÿ", isDrawn: false },
            { id: 2, text: "å‰ç¨‹ä¼¼é”¦ æœªæ¥å¯æœŸ", signature: "æ–‡æ›²æ˜Ÿ", isDrawn: false },
            { id: 3, text: "èº«ä½“å¥åº· ç™¾ç—…ä¸ä¾µ", signature: "å®ˆæŠ¤ç¥", isDrawn: false },
            { id: 4, text: "å¹³å®‰å–œä¹ å²å²æ— å¿§", signature: "ç¦æ˜Ÿ", isDrawn: false },
            { id: 5, text: "å¿ƒæƒ³äº‹æˆ ç¾æ¢¦æˆçœŸ", signature: "è®¸æ„¿æ± ", isDrawn: false },
            { id: 6, text: "è´¢æºå¹¿è¿› æ—¥è¿›æ–—é‡‘", signature: "è´¢ç¥åˆ°", isDrawn: false },
            { id: 7, text: "å¥½è¿è¿è¿ é”¦é²¤é™„ä½“", signature: "é”¦é²¤", isDrawn: false },
            { id: 8, text: "ä¸å¿˜åˆå¿ƒ æ–¹å¾—å§‹ç»ˆ", signature: "é¢†èˆªå‘˜", isDrawn: false }
        ];
        
        // åˆå§‹åŒ–æœ¬åœ°å­˜å‚¨
        function initLocalStorage() {
            try {
                const stored = localStorage.getItem('fortuneDatabase');
                if (stored) {
                    fortuneDatabase = JSON.parse(stored);
                    console.log('  âœ“   å·²ä»æœ¬åœ°å­˜å‚¨æ¢å¤æ•°æ®');
                }
            } catch(e) {
                console.warn('  âš   ï¸ æœ¬åœ°å­˜å‚¨è¯»å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æ•°æ®');
            }
        }
        
        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        function saveToLocalStorage() {
            try {
                localStorage.setItem('fortuneDatabase', JSON.stringify(fortuneDatabase));
                console.log('  âœ“   æ•°æ®å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
            } catch(e) {
                console.warn('  âš   ï¸ æœ¬åœ°å­˜å‚¨ä¿å­˜å¤±è´¥');
            }
        }
        // --- CONFIGURATION ---
        const CONFIG = {
            colors: {
                bg: 0x010205, 
                rockBlue: 0x0088ff,
                textEnergy: 0xffffff, 
                spaceDark: 0x010205,
                // Updated colors for blue theme
                cardFrame: 0x4B9CD3, // Logo Blue
                cardFrameEmissive: 0x0044aa
            },
            particles: {
                // OPTIMIZATION: Balanced count for performance/visual ratio
                count: 8500,
                dustCount: 1000, 
            },
            camera: {
                z: 75 
            }
        };
        const STATE = {
            mode: 'LOGO', 
            focusIndex: -1, 
            focusTarget: null,
            hand: { detected: false, x: 0, y: 0 },
            rotation: { x: 0, y: 0 },
            readyToDraw: false,
            // æ–°å¢ï¼šçˆ†å‘çŠ¶æ€ç®¡ç†
            explosion: {
                active: false,
                triggerTime: 0,
                center: new THREE.Vector3()
            },
            // æ–°å¢ï¼šéœ‡åŠ¨çŠ¶æ€ (ç§»é™¤äº†å…‰çƒ flash çŠ¶æ€)
            shake: 0
        };
        let scene, camera, renderer, composer;
        let mainGroup; 
        let clock = new THREE.Clock();
        let particleSystem = []; 
        let stripMeshGroup = new THREE.Group();
        let handLandmarker, video, webcamCanvas, webcamCtx;
        let logoPoints = []; 
        let meteors = []; // Array to store meteor instances
        let galaxyCore; // æ–°å¢ï¼šé“¶æ²³æ ¸å¿ƒå¯¹è±¡
        
        // Define starUniforms globally to avoid ReferenceError
        let starUniforms = {
            uTime: { value: 0 }
        };
        
        let starFieldGeo, starField; // global refs to star positions used for star links
        let starLinksGroup; // group holding line segments for star-web
        let debrisSystem; // æ–°å¢ï¼šè§£ä½“ç²’å­ç³»ç»Ÿ
        async function init() {
            // é¦–å…ˆåŠ è½½æœ¬åœ°å­˜å‚¨çš„æ•°æ®
            initLocalStorage();

            // --- ä¿®æ”¹ï¼šå°è¯•åŠ è½½ç”¨æˆ·å›¾ç‰‡ Logo ---
            let logoImg = null;
            try {
                // å°è¯•åŠ è½½åŒç›®å½•ä¸‹çš„ "LOGOæ ¡.jpg"
                logoImg = await new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error("Image not found"));
                    img.crossOrigin = "Anonymous"; // å°è¯•å¤„ç†è·¨åŸŸï¼Œä½†åœ¨æœ¬åœ° file:// å¯èƒ½æ— æ•ˆ
                    img.src = 'LOGOæ ¡.jpg'; 
                    
                    // è®¾ç½®ä¸€ä¸ªè¶…æ—¶ï¼Œé˜²æ­¢å›¾ç‰‡åŠ è½½å¡æ­»
                    setTimeout(() => reject(new Error("Timeout")), 1000);
                });
                console.log("  âœ“   å·²åŠ è½½è‡ªå®šä¹‰ Logo: LOGOæ ¡.jpg");
            } catch (e) {
                console.warn("  âš   ï¸ æœªè‡ªåŠ¨æ‰¾åˆ° LOGOæ ¡.jpg (å¯èƒ½æ˜¯æœ¬åœ°è·¨åŸŸé™åˆ¶)ã€‚è¯·å°è¯•å°†å›¾ç‰‡æ‹–å…¥çª—å£ã€‚");
                logoImg = null;
            }
            
            // å°†åŠ è½½åˆ°çš„å›¾ç‰‡ï¼ˆæˆ– nullï¼‰ä¼ ç»™ç”Ÿæˆå‡½æ•°
            generateLogoPoints(logoImg);
            
            initThree();
            setupEnvironment(); 
            createStarfield(); 
            createNebula();
            createGalaxyCore(); // æ–°å¢ï¼šåˆå§‹åŒ–æ ¸å¿ƒ
            setupLights();
            createParticles(); 
            createDust(); 
            createMeteors(); // Init meteors
            
            // Initial strip generation based on DB
            refreshStripsFromDB();
            
            // --- Init Debris System (Card Disintegration) ---
            // ä¿®æ­£ï¼šå°†è§£ä½“ç²’å­ç³»ç»ŸåŠ å…¥ mainGroupï¼Œç¡®ä¿å®ƒéšæ˜Ÿé˜µæ—‹è½¬ï¼Œå®ç°â€œåŸåœ°â€æ•ˆæœ
            debrisSystem = new DebrisSystem();
            mainGroup.add(debrisSystem.mesh); 
            setupPostProcessing();
            setupEvents();
            setupManagerUI(); // Initialize the new UI logic
            setupDragAndDrop(); // æ–°å¢ï¼šæ‹–æ‹½ä¸Šä¼ åŠŸèƒ½
            
            // æ”¹è¿›ï¼šä½¿ç”¨ try-catchï¼Œä¸é˜»å¡ä¸»ç¨‹åº
            try {
                await initMediaPipe();
            } catch (e) {
                console.warn("  âš   ï¸ MediaPipe åˆå§‹åŒ–å¼‚å¸¸:", e);
                // ç»§ç»­æ‰§è¡Œï¼Œåªæ˜¯æ²¡æœ‰æ‰‹åŠ¿è¯†åˆ«åŠŸèƒ½
                updateHint('  ğŸ’¡   æç¤º: æ‰‹åŠ¿è¯†åˆ«åŠŸèƒ½æš‚ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æµè§ˆå™¨æƒé™');
            }
            
            // ä½¿ç”¨ setTimeout å»¶è¿Ÿéšè—åŠ è½½ç•Œé¢ï¼Œç¡®ä¿åœºæ™¯å·²å‡†å¤‡å¥½
            setTimeout(() => {
                const loader = document.getElementById('loader');
                if (loader) {
                    loader.style.opacity = 0;
                    setTimeout(() => {
                        if (loader && loader.parentNode) {
                            loader.remove();
                        }
                    }, 1500);
                }
            }, 500);
            
            animate();
        }

        // --- NEW FUNCTION: Drag and Drop Support ---
        function setupDragAndDrop() {
            const body = document.body;

            body.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });

            body.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();

                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    const file = e.dataTransfer.files[0];
                    if (file.type.match('image.*')) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.onload = () => {
                                // å›¾ç‰‡åŠ è½½æˆåŠŸï¼Œé‡æ–°ç”Ÿæˆç²’å­
                                generateLogoPoints(img);
                                // é‡å»ºç²’å­ç³»ç»Ÿ
                                // 1. æ¸…é™¤æ—§ç²’å­
                                particleSystem.forEach(p => {
                                    if(p.type !== 'STRIP') mainGroup.remove(p.mesh);
                                });
                                particleSystem = particleSystem.filter(p => p.type === 'STRIP'); // ä¿ç•™å¡ç‰‡
                                
                                // 2. åˆ›å»ºæ–°ç²’å­
                                createParticles(); 
                                updateHint("   âœ“    Logo å›¾ç‰‡å·²æ›´æ–°!    ");
                                setTimeout(()=>updateHint("æµç¨‹: æ¡æ‹³é‡ç½® â†’ å¼ å¼€æ‰‹æŒæ¿€æ´» â†’ OKæ‰‹åŠ¿æŠ½å–"), 3000);
                            };
                            img.src = event.target.result; // Data URL is safe for canvas
                        };
                        reader.readAsDataURL(file);
                    } else {
                        updateHint("  âš   ï¸ è¯·æ‹–å…¥å›¾ç‰‡æ–‡ä»¶ (.jpg, .png)");
                    }
                }
            });
        }

        // --- DEBRIS SYSTEM (Updated for "Smash" Effect) ---
        class DebrisSystem {
            constructor() {
                // 3000ä¸ªç²’å­ï¼Œæ¨¡æ‹Ÿç»†è…»çš„ç¢ç‰‡
                this.count = 3000; 
                this.geo = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.count * 3);
                this.velocities = new Float32Array(this.count * 3);
                this.lifes = new Float32Array(this.count); 
                this.scales = new Float32Array(this.count);
                
                // æ–°å¢ï¼šæ¯é¢—ç²’å­çš„ç‹¬ç«‹éšæœºå»¶è¿Ÿæ—¶é—´
                this.returnDelays = new Float32Array(this.count); 
                
                // Init arrays
                for(let i=0; i<this.count; i++) {
                    this.lifes[i] = 0; 
                }
                
                // Set usage to DynamicDrawUsage for attributes that change frequently
                this.geo.setAttribute('position', new THREE.BufferAttribute(this.positions, 3).setUsage(THREE.DynamicDrawUsage));
                this.geo.setAttribute('life', new THREE.BufferAttribute(this.lifes, 1).setUsage(THREE.DynamicDrawUsage));
                this.geo.setAttribute('scale', new THREE.BufferAttribute(this.scales, 1).setUsage(THREE.DynamicDrawUsage));
                
                const mat = new THREE.ShaderMaterial({
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    uniforms: {
                        uColor: { value: new THREE.Color(0x4B9CD3) } // Logo Blue
                    },
                    vertexShader: `
                        attribute float life;
                        attribute float scale;
                        varying float vAlpha;
                        void main() {
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_Position = projectionMatrix * mvPosition;
                            gl_PointSize = scale * (200.0 / -mvPosition.z);
                            vAlpha = life;
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 uColor;
                        varying float vAlpha;
                        void main() {
                            vec2 coord = gl_PointCoord - vec2(0.5);
                            float dist = length(coord);
                            if(dist > 0.5) discard;
                            float glow = 1.0 - (dist * 2.0);
                            glow = pow(glow, 1.5);
                            gl_FragColor = vec4(uColor, vAlpha * glow);
                        }
                    `
                });
                
                this.mesh = new THREE.Points(this.geo, mat);
                this.active = false;
                this.timer = 0; 
            }
            
            explode(origin) {
                this.active = true;
                this.timer = 0; 
                
                const width = 2.2;
                const height = 3.3;
                
                for(let i=0; i<this.count; i++) {
                    // 1. åˆå§‹ä½ç½®ï¼šç²¾ç¡®åŒ¹é…å¡ç‰‡å½¢çŠ¶
                    const lx = (Math.random() - 0.5) * width;
                    const ly = (Math.random() - 0.5) * height;
                    const lz = (Math.random() - 0.5) * 0.1;
                    
                    this.positions[i*3] = origin.x + lx;
                    this.positions[i*3+1] = origin.y + ly;
                    this.positions[i*3+2] = origin.z + lz;
                    
                    // 2. "æ‘”ç¢"å¼é€Ÿåº¦ (Shatter Velocity) - å¤§å¹…å¢åŠ åˆå§‹é€Ÿåº¦
                    const explodePower = 15.0 + Math.random() * 10.0; // æ›´çŒ›çƒˆçš„ç‚¸å¼€
                    
                    // éšæœºæ–¹å‘
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI; 
                    
                    this.velocities[i*3] = explodePower * Math.sin(phi) * Math.cos(theta);
                    this.velocities[i*3+1] = explodePower * Math.sin(phi) * Math.sin(theta);
                    this.velocities[i*3+2] = explodePower * Math.cos(phi);
                    
                    this.lifes[i] = 1.0;
                    // ä¿®æ”¹ï¼šç²’å­ä½“ç§¯ç¿»å€ (10.0 + random * 20.0)ï¼Œå¢å¼ºç¢ç‰‡æ„Ÿ
                    this.scales[i] = 10.0 + Math.random() * 20.0; 
                    
                    // 3. éšæœºå½’ä½å»¶è¿Ÿ - å¢åŠ æ»ç•™æ—¶é—´
                    this.returnDelays[i] = 1.2 + Math.random() * 3.0; 
                }
                this.geo.attributes.position.needsUpdate = true;
                this.geo.attributes.life.needsUpdate = true;
            }
            
            update(dt) {
                if(!this.active) return;
                
                this.timer += dt;
                let activeCount = 0;
                
                const positions = this.geo.attributes.position.array;
                const lifes = this.geo.attributes.life.array;
                
                for(let i=0; i<this.count; i++) {
                    if(lifes[i] <= 0) continue;
                    activeCount++;
                    
                    const idx = i*3;
                    
                    // åˆ¤æ–­å½“å‰ç²’å­æ˜¯å¦è¯¥å›å®¶äº†
                    const shouldReturn = this.timer > this.returnDelays[i];
                    
                    if (!shouldReturn) {
                        // --- é˜¶æ®µä¸€ï¼šæ‘”ç¢ä¸æ•£è½ (Shatter & Fall) ---
                        
                        // 1. å¼ºç©ºæ°”é˜»åŠ› (Drag) - æ¨¡æ‹Ÿå­å¼¹æ—¶é—´æ•ˆæœ
                        const drag = 0.85; // å¼ºé˜»åŠ›
                        this.velocities[idx] *= drag;
                        this.velocities[idx+1] *= drag;
                        this.velocities[idx+2] *= drag;
                        // 2. å»¶è¿Ÿé‡åŠ› (Delayed Gravity)
                        if (this.timer > 0.15) {
                             this.velocities[idx+1] -= 8.0 * dt; // å¼€å§‹ä¸‹è½
                        }
                        
                        // æ›´æ–°ä½ç½®
                        positions[idx] += this.velocities[idx] * dt;
                        positions[idx+1] += this.velocities[idx+1] * dt;
                        positions[idx+2] += this.velocities[idx+2] * dt;
                        
                    } else {
                        // --- é˜¶æ®µäºŒï¼šå½’å·¢ (Homing) ---
                        const px = positions[idx];
                        const py = positions[idx+1];
                        const pz = positions[idx+2];
                        
                        const dx = 0 - px;
                        const dy = 0 - py;
                        const dz = 0 - pz;
                        const distSq = dx*dx + dy*dy + dz*dz;
                        
                        const dist = Math.sqrt(distSq);
                        if (dist < 0.1) {
                            lifes[i] = 0; 
                            continue;
                        }
                        
                        // å½’å·¢é€Ÿåº¦
                        const speed = 20.0; 
                        const dirX = dx / dist;
                        const dirY = dy / dist;
                        const dirZ = dz / dist;
                        
                        this.velocities[idx] += (dirX * speed - this.velocities[idx]) * 2.0 * dt;
                        this.velocities[idx+1] += (dirY * speed - this.velocities[idx+1]) * 2.0 * dt;
                        this.velocities[idx+2] += (dirZ * speed - this.velocities[idx+2]) * 2.0 * dt;
                        
                        // 2. æ··æ²Œæ‰°åŠ¨ (Curl Noise)
                        const waveFreq = 2.0;
                        const waveAmp = 10.0;
                        this.velocities[idx] += Math.sin(this.timer * waveFreq + i) * waveAmp * dt;
                        this.velocities[idx+1] += Math.cos(this.timer * waveFreq + i * 0.5) * waveAmp * dt;
                        this.velocities[idx+2] += Math.sin(this.timer * waveFreq * 0.7 + i) * waveAmp * dt;
                        
                        positions[idx] += this.velocities[idx] * dt;
                        positions[idx+1] += this.velocities[idx+1] * dt;
                        positions[idx+2] += this.velocities[idx+2] * dt;
                        
                        if (distSq < 100) {
                            lifes[i] -= dt * 1.5;
                        }
                    }
                }
                
                if(activeCount === 0) this.active = false;
                
                this.geo.attributes.position.needsUpdate = true;
                this.geo.attributes.life.needsUpdate = true;
            }
        }
        // --- PROCEDURAL LOGO GENERATION (UPDATED FOR IMAGE) ---
        function generateLogoPoints(image) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            
            // --- ä¿®æ”¹æ ¸å¿ƒï¼šå¦‚æœæœ‰å›¾ç‰‡ï¼Œç»˜åˆ¶å›¾ç‰‡ï¼›å¦åˆ™ç»˜åˆ¶é»˜è®¤ Logo ---
            // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦ try-catchï¼Œé˜²æ­¢ tainted canvas æŠ¥é”™å¯¼è‡´æ•´ä¸ªé¡µé¢å´©æºƒ
            try {
                if (image) {
                    // ä¿æŒæ¯”ä¾‹ç»˜åˆ¶å›¾ç‰‡åˆ° Canvas ä¸­å¿ƒ
                    const aspect = image.width / image.height;
                    let drawW = size;
                    let drawH = size;
                    if (aspect > 1) {
                        drawH = size / aspect; // å®½å›¾ï¼Œé«˜åº¦è‡ªé€‚åº”
                    } else {
                        drawW = size * aspect; // é«˜å›¾ï¼Œå®½åº¦è‡ªé€‚åº”
                    }
                    const drawX = (size - drawW) / 2;
                    const drawY = (size - drawH) / 2;
                    
                    ctx.drawImage(image, drawX, drawY, drawW, drawH);
                    
                } else {
                    // --- åŸæœ‰çš„ç¨‹åºåŒ–ç»˜åˆ¶é€»è¾‘ (ä½œä¸º Fallback) ---
                    const cx = size / 2;
                    const cy = size / 2;
                    const outerR = size * 0.45;
                    const innerR = size * 0.30;
                    
                    const borderGap = 15;
                    const borderR = outerR + borderGap; 
                    
                    ctx.beginPath();
                    ctx.arc(cx, cy, borderR, 0, Math.PI * 2);
                    ctx.strokeStyle = '#4B9CD3';
                    ctx.lineWidth = 6;
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.arc(cx, cy, outerR, 0, Math.PI * 2);
                    ctx.arc(cx, cy, innerR, 0, Math.PI * 2, true); 
                    ctx.fillStyle = '#4B9CD3';
                    ctx.fill();
                    
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(-Math.PI / 4); 
                    ctx.font = 'bold 180px sans-serif'; 
                    ctx.fillStyle = '#4B9CD3';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('   âœˆ   ', 0, 10); 
                    ctx.restore();
                    
                    drawTextAlongArc(ctx, "CEHM", cx, cy, (outerR + innerR) / 2, Math.PI / 2, -0.4, 65, '#FFFFFF');
                    drawTextAlongArc(ctx, "æ•™è‚²å¥åº·ç®¡ç†å­¦é™¢", cx, cy, (outerR + innerR) / 2, -Math.PI / 2, 0.6, 52, '#FFFFFF');
                }
                
                // --- é‡‡æ ·ç”Ÿæˆç²’å­ç‚¹ ---
                const imgData = ctx.getImageData(0, 0, size, size);
                const data = imgData.data;
                const cx = size / 2;
                const cy = size / 2;
                
                logoPoints = []; // æ¸…ç©ºä¹‹å‰çš„ç‚¹ï¼ˆå¦‚æœæœ‰ï¼‰

                // High density sampling
                for (let y = 0; y < size; y += 2) { 
                    for (let x = 0; x < size; x += 2) {
                        const i = (y * size + x) * 4;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const alpha = data[i + 3];
                        
                        // --- é‡‡æ ·é€»è¾‘ä¼˜åŒ–ï¼šå¢åŠ äº®åº¦æ£€æµ‹ ---
                        // 1. å¦‚æœæ˜¯é€æ˜ PNGï¼Œæ£€æŸ¥ Alpha
                        // 2. å¦‚æœæ˜¯é»‘è‰²èƒŒæ™¯ JPGï¼Œæ£€æŸ¥ RGB äº®åº¦
                        const brightness = (r + g + b) / 3;
                        
                        if (alpha > 128 && brightness > 30) {
                            
                            let colorType = 'BLUE';
                            // ç®€å•çš„é¢œè‰²åˆ†ç±»ï¼šå¦‚æœæ¯”è¾ƒäº®/ç™½ï¼Œå°±æ˜¯ TEXT ç±»å‹ï¼ˆå‘ç™½å…‰ï¼‰ï¼Œå¦åˆ™æ˜¯ BLUE
                            if (r > 200 && g > 200 && b > 200) colorType = 'TEXT';
                            
                            const pX = (x - cx) / size * 55; 
                            const pY = -(y - cy) / size * 55; 
                            
                            logoPoints.push({
                                x: pX, 
                                y: pY, 
                                z: (Math.random() - 0.5) * 2.0, 
                                type: colorType
                            });
                        }
                    }
                }
                
                // Shuffle points to reduce grid artifacts
                for (let i = logoPoints.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [logoPoints[i], logoPoints[j]] = [logoPoints[j], logoPoints[i]];
                }
            } catch (err) {
                console.error("ç”Ÿæˆ Logo ç²’å­å¤±è´¥ (å¯èƒ½æ˜¯è·¨åŸŸå›¾ç‰‡æ±¡æŸ“äº† Canvas):", err);
                updateHint(" âš   æœ¬åœ°å›¾ç‰‡åŠ è½½å—é™ï¼Œè¯·å°è¯•å°†å›¾ç‰‡æ‹–å…¥çª—å£ ");
                // å¦‚æœå¤±è´¥ï¼Œç¡®ä¿ logoPoints è‡³å°‘æœ‰ä¸€äº›ç‚¹ï¼Œé˜²æ­¢æŠ¥é”™
                if (logoPoints.length === 0) {
                    // ç´§æ€¥å›é€€åˆ°æœ€ç®€å•çš„åœ†å½¢
                     for(let i=0; i<2000; i++) {
                         const th = Math.random()*Math.PI*2;
                         const rad = 20 + Math.random()*5;
                         logoPoints.push({x: Math.cos(th)*rad, y: Math.sin(th)*rad, z:0, type:'BLUE'});
                     }
                }
            }
        }
        function drawTextAlongArc(ctx, str, cx, cy, radius, startAngle, spread, fontSize, color) {
            ctx.font = `900 ${fontSize}px "Microsoft YaHei", "SimHei", sans-serif`;
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const totalAngle = spread * Math.PI; 
            const anglePerChar = totalAngle / (str.length - 1 || 1);
            const start = startAngle - totalAngle / 2;
            for (let i = 0; i < str.length; i++) {
                const char = str[i];
                const angle = start + i * anglePerChar;
                
                ctx.save();
                ctx.translate(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
                ctx.rotate(angle + Math.PI / 2); 
                ctx.fillText(char, 0, 0);
                ctx.restore();
            }
        }
        // --- BACKGROUND GENERATION ---
        function createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsCount = 4000; // å¢åŠ æ•°é‡ä»¥æ„å»ºæ›´å¯†é›†çš„èƒŒæ™¯
            const posArray = new Float32Array(starsCount * 3);
            const scaleArray = new Float32Array(starsCount);
            const phaseArray = new Float32Array(starsCount); // é—ªçƒç›¸ä½
            const colorArray = new Float32Array(starsCount * 3); // æ˜Ÿæ˜Ÿé¢œè‰²
            // å®šä¹‰æ˜Ÿå…‰è°ƒè‰²ç›˜ (æ›´è´´è¿‘çœŸå®æ˜Ÿæ˜Ÿ: è“ç™½ã€ç™½ã€æ·¡è“)
            const starColors = [
                new THREE.Color(0xaaddff), // è“ç™½
                new THREE.Color(0xffffff), // çº¯ç™½
                new THREE.Color(0x99ccff), // æ·¡è“
                new THREE.Color(0xcce6ff), // æ›´æ·¡çš„è“ç™½
                new THREE.Color(0xbbeeff)  // å†·ç™½
            ];
            for(let i = 0; i < starsCount * 3; i+=3) {
                const r = 400 + Math.random() * 800; // æ‹‰å¤§è·ç¦»èŒƒå›´ï¼Œå¢åŠ æ·±ç©ºæ„Ÿ
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                posArray[i] = r * Math.sin(phi) * Math.cos(theta);
                posArray[i+1] = r * Math.sin(phi) * Math.sin(theta);
                posArray[i+2] = r * Math.cos(phi);
                
                // ä¼˜åŒ–å¤§å°åˆ†å¸ƒï¼šä½¿ç”¨ Math.pow è®©å°æ˜Ÿæ˜Ÿæ›´å¤šï¼Œå¤§æ˜Ÿæ˜Ÿæ›´å°‘
                // åŸºç¡€å¤§å° 0.5ï¼Œæœ€å¤§åŠ æˆ 3.0ï¼ŒæŒ‡æ•° 4 (æå°‘æ•°éå¸¸äº®)
                scaleArray[i/3] = 0.5 + Math.pow(Math.random(), 4) * 3.0; 
                
                // éšæœºé—ªçƒç›¸ä½
                phaseArray[i/3] = Math.random() * Math.PI * 2;
                // éšæœºåˆ†é…é¢œè‰²
                const color = starColors[Math.floor(Math.random() * starColors.length)];
                // ç¨å¾®å¢åŠ ä¸€ç‚¹éšæœºäº®åº¦å·®å¼‚
                const brightness = 0.8 + Math.random() * 0.2;
                colorArray[i] = color.r * brightness;
                colorArray[i+1] = color.g * brightness;
                colorArray[i+2] = color.b * brightness;
            }
            starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            starsGeometry.setAttribute('aScale', new THREE.BufferAttribute(scaleArray, 1));
            starsGeometry.setAttribute('aPhase', new THREE.BufferAttribute(phaseArray, 1));
            starsGeometry.setAttribute('aColor', new THREE.BufferAttribute(colorArray, 3));
            // è‡ªå®šä¹‰ç€è‰²å™¨æ¥å®ç°é—ªçƒåŠ¨ç”»
            // starUniforms defined globally now
            const starMaterial = new THREE.ShaderMaterial({
                uniforms: starUniforms,
                vertexShader: `
                    attribute float aScale;
                    attribute float aPhase;
                    attribute vec3 aColor;
                    varying float vAlpha;
                    varying vec3 vColor;
                    uniform float uTime;
                    
                    // ä¼ªéšæœºå‡½æ•°
                    float rand(float n){return fract(sin(n) * 43758.5453123);}
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // è·ç¦»è¡°å‡å¤§å°
                        gl_PointSize = ( 100.0 * aScale ) / - mvPosition.z;
                        
                        // é—ªçƒé€»è¾‘ä¼˜åŒ–: 
                        // 1. æ¯é¢—æ˜Ÿæ˜Ÿæœ‰ä¸åŒçš„é—ªçƒé€Ÿåº¦ (åŸºäº aPhase çš„éšæœºå€¼)
                        float speed = 0.5 + 1.5 * rand(aPhase); 
                        
                        // 2. æ­£å¼¦æ³¢é—ªçƒ
                        float blink = sin(uTime * speed + aPhase);
                        
                        // 3. äº®åº¦æ˜ å°„: ä¿è¯æœ€å°äº®åº¦ä¸ä¸º0ï¼Œå¤§æ˜Ÿæ˜Ÿé—ªçƒæ›´æ˜æ˜¾
                        // å°æ˜Ÿæ˜ŸåŸºç¡€äº®åº¦ä½ï¼Œå¤§æ˜Ÿæ˜ŸåŸºç¡€äº®åº¦é«˜
                        float baseAlpha = 0.3 + 0.4 * rand(aPhase + 1.0);
                        vAlpha = baseAlpha + 0.4 * (0.5 + 0.5 * blink);
                        
                        vColor = aColor;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;
                    
                    void main() {
                        // ç»˜åˆ¶åœ†å½¢ç²’å­ (é»˜è®¤æ˜¯æ–¹å½¢)
                        vec2 uv = gl_PointCoord.xy - 0.5;
                        float dist = length(uv);
                        
                        // è£å‰ªæ‰åœ†å½¢ä»¥å¤–çš„éƒ¨åˆ†
                        if (dist > 0.5) discard;
                        
                        // è¾¹ç¼˜æŸ”åŒ– (ä¸­å¿ƒäº®ï¼Œè¾¹ç¼˜æš—ï¼ŒæŒ‡æ•°è¡°å‡æ¨¡æ‹Ÿå…‰æ™•)
                        float glow = 1.0 - (dist * 2.0);
                        glow = pow(glow, 2.0); 
                        
                        gl_FragColor = vec4( vColor, vAlpha * glow );
                    }
                `,
                transparent: true,
                depthWrite: false, // ç¦æ­¢æ·±åº¦å†™å…¥ï¼Œé˜²æ­¢é®æŒ¡é—®é¢˜
                blending: THREE.AdditiveBlending // å åŠ æ··åˆï¼Œæ›´æœ‰å‘å…‰æ„Ÿ
            });
            const starField = new THREE.Points(starsGeometry, starMaterial);
            scene.add(starField);
        }
        function createNebula() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            grad.addColorStop(0, 'rgba(60, 10, 20, 0.3)'); 
            grad.addColorStop(0.6, 'rgba(40, 10, 60, 0.1)'); 
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,128,128);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ 
                map: tex, transparent: true, opacity: 0.5, depthWrite: false, blending: THREE.AdditiveBlending 
            });
            for(let i=0; i<8; i++) {
                const sprite = new THREE.Sprite(mat);
                const r = 150 + Math.random() * 50;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI; 
                sprite.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi) - 50);
                const scale = 120 + Math.random() * 100;
                sprite.scale.set(scale, scale, 1);
                scene.add(sprite);
            }
        }
        // æ–°å¢ï¼šåˆ›å»ºé“¶æ²³æ ¸å¿ƒå‡½æ•°
        function createGalaxyCore() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // ä¼˜åŒ–ï¼šä½¿ç”¨ Logo åŒè‰²ç³»çš„æ·±é‚ƒè“ï¼Œé™ä½äº®åº¦ï¼Œé¿å…è¿‡æ›
            const grad = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            
            // æ ¸å¿ƒï¼šä¸å†æ˜¯åˆºçœ¼çš„çº¯ç™½ï¼Œè€Œæ˜¯æŸ”å’Œçš„æ˜Ÿäº‘è“ç™½ï¼Œé€æ˜åº¦é™ä½
            grad.addColorStop(0, 'rgba(150, 200, 255, 0.5)'); 
            
            // å†…ç¯ï¼šä½¿ç”¨ Logo æ ‡å‡†è‰² #4B9CD3ï¼Œå¤§å¹…é™ä½é€æ˜åº¦ï¼Œè¥é€ æ°”ä½“æ„Ÿ
            grad.addColorStop(0.25, 'rgba(75, 156, 211, 0.25)');
            
            // å¤–ç¯ï¼šæ·±é‚ƒçš„å®‡å®™è“ï¼Œä¸èƒŒæ™¯èåˆ
            grad.addColorStop(0.6, 'rgba(10, 30, 60, 0.1)');
            
            // è¾¹ç¼˜ï¼šå®Œå…¨é€æ˜
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 128, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                // ç¨å¾®å¸¦ä¸€ç‚¹è“è‰²çš„ tintï¼Œç¡®ä¿é¢œè‰²ä¸€è‡´æ€§
                color: 0x88ccff, 
                transparent: true, 
                opacity: 0, // åˆå§‹é€æ˜ï¼Œç”± Logo æ¨¡å¼æ§åˆ¶
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            galaxyCore = new THREE.Sprite(material);
            // ç¨å¾®å¢å¤§ä¸€ç‚¹èŒƒå›´ï¼Œä½†å› ä¸ºé€æ˜åº¦ä½ï¼Œä¼šæ˜¾å¾—æ›´æ·±é‚ƒ
            galaxyCore.scale.set(100, 100, 1); 
            mainGroup.add(galaxyCore);
        }
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(0x100505, 0.002); 
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, CONFIG.camera.z); 
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = 1.0; 
            container.appendChild(renderer.domElement);
            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }
        function setupEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        }
        function setupLights() {
            const ambient = new THREE.AmbientLight(0x442222, 0.2); 
            scene.add(ambient);
            const sunLight = new THREE.DirectionalLight(0xffddaa, 1.2);
            sunLight.position.set(50, 30, 50);
            scene.add(sunLight);
            const rimLight = new THREE.SpotLight(0xff3333, 8.0);
            rimLight.position.set(-40, 0, 10);
            rimLight.lookAt(0,0,0);
            scene.add(rimLight);
            const centerLight = new THREE.PointLight(0xffaa00, 2, 40);
            mainGroup.add(centerLight);
        }
        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2; 
            bloomPass.strength = 0.8;  
            bloomPass.radius = 0.4;    
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }
        // --- METEOR SYSTEM (NATURAL & RANDOM) ---
        // --- IMPROVED METEOR SYSTEM (REALISTIC) ---
        
        // 1. Generate Gradient Texture for Tail
        function createMeteorTailTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createLinearGradient(0, 256, 0, 0); // Bottom to Top
            grad.addColorStop(0, 'rgba(0, 0, 20, 0)'); // Tail End (Transparent)
            grad.addColorStop(0.3, 'rgba(50, 100, 255, 0.05)'); // Very Faint Blue
            grad.addColorStop(0.7, 'rgba(150, 220, 255, 0.2)'); // Subtle Cyan
            grad.addColorStop(1, 'rgba(255, 255, 255, 0.8)'); // Head connection (White)
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 256);
            return new THREE.CanvasTexture(canvas);
        }
        // 2. Generate Glow Texture for Head
        function createMeteorHeadTexture() {
             const canvas = document.createElement('canvas');
             canvas.width = 64; canvas.height = 64;
             const ctx = canvas.getContext('2d');
             const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
             grad.addColorStop(0, 'rgba(255,255,255,1)');
             grad.addColorStop(0.1, 'rgba(200,240,255,0.5)'); // Tighter core
             grad.addColorStop(0.4, 'rgba(100,200,255,0.1)');
             grad.addColorStop(1, 'rgba(0,0,0,0)');
             ctx.fillStyle = grad;
             ctx.fillRect(0,0,64,64);
             return new THREE.CanvasTexture(canvas);
        }
        const meteorTailTex = createMeteorTailTexture();
        const meteorHeadTex = createMeteorHeadTexture();
        class Meteor {
            constructor() {
                this.mesh = new THREE.Group();
                
                // å¢åŠ éšæœºé¢œè‰² (é’è‰²-è“è‰²-ç´«è‰²)ï¼Œè®©æµæ˜Ÿæ›´ä¸°å¯Œå¤šå½©
                const hue = 0.55 + Math.random() * 0.15; 
                const color = new THREE.Color().setHSL(hue, 0.9, 0.9);
                // Head (Glowing Sprite)
                const spriteMat = new THREE.SpriteMaterial({
                    map: meteorHeadTex,
                    color: color, // åº”ç”¨éšæœºé¢œè‰²
                    transparent: true,
                    opacity: 0,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                this.head = new THREE.Sprite(spriteMat);
                // REDUCED SCALE: Smaller, star-like head
                this.head.scale.set(2.0, 2.0, 1); 
                this.mesh.add(this.head);
                // Tail (Crossed Planes)
                // REDUCED DIMENSIONS: Thinner and slightly shorter for speed effect
                const len = 60;
                const width = 0.3; // Much thinner
                const geo = new THREE.PlaneGeometry(width, len);
                geo.translate(0, -len/2, 0); 
                const tailMat = new THREE.MeshBasicMaterial({ 
                    map: meteorTailTex,
                    color: color, // å°¾å·´ä¹Ÿåº”ç”¨åŒè‰²ç³»
                    transparent: true, 
                    opacity: 0,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const plane1 = new THREE.Mesh(geo, tailMat);
                const plane2 = new THREE.Mesh(geo, tailMat);
                plane2.rotation.y = Math.PI / 2; 
                this.mesh.add(plane1);
                this.mesh.add(plane2);
                this.materials = [spriteMat, tailMat];
                this.reset();
                scene.add(this.mesh);
            }
            reset() {
                this.active = false;
                this.materials.forEach(m => m.opacity = 0);
                // Random delay: 0.2s to 2.5s (Frequent but random)
                this.delay = Math.random() * 2.3 + 0.2; 
                this.mesh.position.set(0, -9999, 0); 
            }
            spawn() {
                this.active = true;
                // REDUCED OPACITY: More subtle/realistic
                const maxOpacity = 0.4 + Math.random() * 0.4;
                this.materials.forEach(m => m.opacity = maxOpacity);
                
                // 1. Random Start Position
                const r = 180 + Math.random() * 200; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                const startPos = new THREE.Vector3(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                this.mesh.position.copy(startPos);
                
                // 2. Target
                // å¢åŠ æ’å‡»æ¦‚ç‡ï¼šå¼•å…¥å¼•å¯¼æœºåˆ¶
                let target;
                // 20% çš„æ¦‚ç‡ç›´æ¥ç„å‡† Logo ä¸­å¿ƒåŒºåŸŸ
                if (Math.random() < 0.2) {
                    target = new THREE.Vector3(
                        (Math.random()-0.5) * 60,  // ç¼©å°èŒƒå›´ï¼Œèšç„¦ä¸­å¿ƒ
                        (Math.random()-0.5) * 60, 
                        (Math.random()-0.5) * 20 
                    );
                } else {
                    // å‰©ä¸‹çš„ä¿æŒéšæœºæ¼«å°„ï¼Œè¥é€ ç¯å¢ƒæ„Ÿ
                    target = new THREE.Vector3(
                        (Math.random()-0.5) * 400, 
                        (Math.random()-0.5) * 400, 
                        (Math.random()-0.5) * 100
                    );
                }
                
                // 3. Velocity - INCREASED SPEED significantly
                const speed = 400 + Math.random() * 300; 
                this.velocity = target.sub(startPos).normalize().multiplyScalar(speed);
                
                // 4. Orientation
                const lookTarget = this.mesh.position.clone().add(this.velocity);
                this.mesh.lookAt(lookTarget);
                this.mesh.rotateX(-Math.PI / 2); 
            }
            update(dt) {
                if (!this.active) {
                    this.delay -= dt;
                    if (this.delay <= 0) this.spawn();
                    return;
                }
                // Move
                this.mesh.position.add(this.velocity.clone().multiplyScalar(dt));
                
                // Fade out faster
                this.materials.forEach(m => m.opacity -= dt * 1.0); 
                if (this.materials[0].opacity <= 0) {
                    this.reset();
                }
            }
        }
        function createMeteors() {
            // æŒ‰ç…§è¦æ±‚ï¼šåœ¨10çš„åŸºç¡€ä¸Šå¢åŠ 1é¢—ï¼Œå…±11é¢—æµæ˜Ÿ
            for (let i = 0; i < 11; i++) {
                meteors.push(new Meteor());
            }
        }
        // --- MANAGER UI LOGIC ---
        function setupManagerUI() {
            const modal = document.getElementById('manager-modal');
            const openBtn = document.getElementById('open-manager-btn');
            const closeBtn = document.getElementById('close-manager-btn');
            const listContainer = document.getElementById('card-list-container');
            const addBtn = document.getElementById('mgr-add-btn');
            const resetBtn = document.getElementById('mgr-reset-btn');
            // Toggle
            openBtn.addEventListener('click', () => {
                renderCardList();
                modal.classList.remove('hidden');
            });
            closeBtn.addEventListener('click', () => modal.classList.add('hidden'));
            // Add Card
            addBtn.addEventListener('click', () => {
                const textInput = document.getElementById('mgr-text');
                const sigInput = document.getElementById('mgr-sig');
                const text = textInput.value.trim();
                const sig = sigInput.value.trim() || "åŒ¿å";
                
                if (text) {
                    const newId = Date.now();
                    fortuneDatabase.push({ id: newId, text: text, signature: sig, isDrawn: false });
                    textInput.value = "";
                    sigInput.value = "";
                    renderCardList();
                    refreshStripsFromDB(); // Sync 3D
                    saveToLocalStorage(); // ä¿å­˜æ•°æ®
                }
            });
            // Reset All
            resetBtn.addEventListener('click', () => {
                fortuneDatabase.forEach(card => card.isDrawn = false);
                renderCardList();
                refreshStripsFromDB(); // Sync 3D (to reset colors/states)
                saveToLocalStorage(); // ä¿å­˜æ•°æ®
            });
            // Delegate events (Delete & Reset Single)
            listContainer.addEventListener('click', (e) => {
                const id = parseInt(e.target.dataset.id);
                
                // Handle Delete
                if (e.target.classList.contains('delete-btn')) {
                    fortuneDatabase = fortuneDatabase.filter(c => c.id !== id);
                    renderCardList();
                    refreshStripsFromDB();
                    saveToLocalStorage(); // ä¿å­˜æ•°æ®
                }
                
                // Handle Reset Single Card
                if (e.target.classList.contains('reset-btn')) {
                    const card = fortuneDatabase.find(c => c.id === id);
                    if(card) {
                        card.isDrawn = false; // Reset status
                        renderCardList();     // Update UI
                        refreshStripsFromDB(); // Update 3D scene
                        saveToLocalStorage(); // ä¿å­˜æ•°æ®
                    }
                }
            });
        }
        function renderCardList() {
            const container = document.getElementById('card-list-container');
            container.innerHTML = '';
            
            let drawnCount = 0;
            fortuneDatabase.forEach(card => {
                if(card.isDrawn) drawnCount++;
                
                const item = document.createElement('div');
                item.className = `card-item ${card.isDrawn ? 'drawn' : 'active'}`;
                
                // Logic for showing the reset button only if drawn
                const resetButton = card.isDrawn ? `<span class="reset-btn" data-id="${card.id}" title="é‡æ–°æ”¾å…¥æ˜Ÿç©º">   â†»    å½’ä½</span>` : '';
                item.innerHTML = `
                    <div class="card-info" style="flex:1">
                        <div class="card-text">${card.text}</div>
                        <div class="card-sig">
                            ${card.isDrawn ? '<span class="card-status status-drawn">å·²æŠ½å–</span>' : '<span class="card-status status-new">å¾…æŠ½å–</span>'}
                            ${card.signature}
                        </div>
                    </div>
                    <div style="display:flex; align-items:center;">
                        ${resetButton}
                        <div class="delete-btn" data-id="${card.id}" title="åˆ é™¤">Ã—</div>
                    </div>
                `;
                container.appendChild(item);
            });
            document.getElementById('card-count').innerText = fortuneDatabase.length;
            document.getElementById('drawn-count').innerText = drawnCount;
        }
        // --- 3D SCENE SYNC ---
        function refreshStripsFromDB() {
            // 1. Clear existing strips from Scene
            stripMeshGroup.clear(); // Three.js helper to remove children
            
            // 2. Remove strip particles from system array
            particleSystem = particleSystem.filter(p => p.type !== 'STRIP');
            // 3. Rebuild based on DB
            fortuneDatabase.forEach(card => {
                const tex = createStripTexture(card.text, card.signature);
                addStripToScene(tex, card.id);
            });
        }
        // --- PARTICLE UPDATE LOGIC WITH COLLISION ---
        // æ›´æ–° Particle ç±»ä»¥æ”¯æŒç¢°æ’
        class Particle {
            constructor(mesh, targetPoint) {
                this.mesh = mesh;
                this.isDust = false;
                this.type = targetPoint.type; 
                this.isDrawn = false; 
                this.dbId = targetPoint.dbId || null; 
                
                this.posLogo = new THREE.Vector3(targetPoint.x, targetPoint.y, targetPoint.z);
                this.posScatter = new THREE.Vector3();
                this.currentTarget = new THREE.Vector3(); 
                // æ–°å¢ï¼šçˆ†å‘é€Ÿåº¦å‘é‡
                this.explosionVelocity = new THREE.Vector3(0, 0, 0);
                // ä¿®æ­£ï¼šå¦‚æœæ˜¯å¡ç‰‡(STRIP)ï¼Œå¼ºåˆ¶åŸºç¡€å¤§å°ä¸º 1ï¼Œç¡®ä¿æ•£å¼€æ—¶å¯è§
                // æ™®é€šç²’å­åˆ™ä½¿ç”¨ mesh è‡ªèº«çš„ç¼©æ”¾
                if (this.type === 'STRIP') {
                    this.baseScale = 1.0; 
                } else {
                    this.baseScale = mesh.scale.x; 
                }
                // Flight Animation State
                this.isFlying = false;
                this.flightProgress = 0;
                this.flightStartPos = new THREE.Vector3();
                this.flightControlPos = new THREE.Vector3(); // For Bezier curve
                this.flightDuration = 1.0;
                this.flightDelay = 0; 
                
                this.isDissolving = false;
                this.dissolveTimer = 0;
                const rScatter = 40 + Math.random() * 40; 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(
                    rScatter * Math.sin(phi) * Math.cos(theta),
                    rScatter * Math.sin(phi) * Math.sin(theta),
                    rScatter * Math.cos(phi)
                );
                this.mesh.position.copy(this.posScatter);
                
                this.rotSpeed = new THREE.Vector3(
                    (Math.random()-0.5) * 2.0,
                    (Math.random()-0.5) * 2.0,
                    (Math.random()-0.5) * 2.0
                );
            }
            
            dissolve() {
                // ä¿®æ”¹ï¼šç¬é—´æ¶ˆå¤±ï¼Œé…åˆç¢è£‚
                this.isDissolving = true;
                this.dissolveTimer = 0;
                this.mesh.scale.setScalar(0); // ç«‹å³éšè—
            }
            // activeMeteorsLocal: è½¬æ¢åˆ°å±€éƒ¨åæ ‡ç³»çš„æµæ˜Ÿä½ç½®æ•°ç»„
            update(dt, mode, focusTargetMesh, activeMeteorsLocal) {
                let s = this.baseScale;
                
                if (this.isDissolving) {
                    // ä¸éœ€è¦æ¸éšåŠ¨ç”»ï¼Œç›´æ¥ä¿æŒéšè—
                    return;
                }
                // --- ç‰©ç†åŠ¨åŠ›å­¦æ›´æ–° (çˆ†ç‚¸å¤„ç†) ---
                // 1. åº”ç”¨çˆ†ç‚¸é€Ÿåº¦åˆ°ä½ç½®
                this.mesh.position.add(this.explosionVelocity.clone().multiplyScalar(dt));
                // 2. é˜»åŠ›è¡°å‡ (Drag)
                this.explosionVelocity.multiplyScalar(0.92); // 0.92 per frame approx
                
                const explosionInfluence = this.explosionVelocity.length();
                // Reuse Logo Motion Logic
                const applyLogoMotion = () => {
                    this.mesh.rotation.x += this.rotSpeed.x * dt * 0.5;
                    this.mesh.rotation.y += this.rotSpeed.y * dt * 0.5;
                    this.mesh.rotation.z += this.rotSpeed.z * dt * 0.5;
                    const drift = Math.sin(clock.elapsedTime * 0.5 + this.mesh.position.x * 0.1) * 0.2;
                    this.currentTarget.copy(this.posLogo);
                    this.currentTarget.y += drift;
                };
                
                // RESET FLIGHT if not focused
                if (mode !== 'FOCUS' || this.mesh !== focusTargetMesh) {
                    this.isFlying = false;
                    this.flightProgress = 0;
                    this.flightDelay = 0;
                }
                if (mode === 'SCATTER') {
                    this.currentTarget.copy(this.posScatter);
                    // Standard lerp for scatter
                    this.mesh.rotation.x += this.rotSpeed.x * dt;
                    this.mesh.rotation.y += this.rotSpeed.y * dt;
                    this.mesh.position.lerp(this.currentTarget, 2.0 * dt);
                    
                    // ä¿®æ­£ï¼šSCATTER æ¨¡å¼ä¸‹ï¼Œå¡ç‰‡åº”è¯¥æ¢å¤åˆ° baseScale (1.0)
                    this.mesh.scale.lerp(new THREE.Vector3(s,s,s), 3*dt);
                
                } else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        // Focus æ¨¡å¼ä¸‹çš„é€»è¾‘ä¿æŒä¸å˜...
                        const desiredWorldPos = new THREE.Vector3(0, 0, 40); 
                        const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                        const finalTarget = desiredWorldPos.applyMatrix4(invMatrix);
                        s = 3.8; 
                        
                        // ç¡®ä¿é€æ˜åº¦é‡ç½® (å¦‚æœä¹‹å‰æ¶ˆèè¿‡)
                        // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦é‡æ–°è®¾ç½® scale ä¸ºå¯è§ï¼Œå¦‚æœè¢« dissolve è®¾ç½®ä¸º0çš„è¯
                        // ä½†åªæœ‰å½“ä¸åœ¨ dissolve çŠ¶æ€æ—¶æ‰é‡ç½®
                        if (!this.isDissolving) {
                             // do nothing, scale is managed by lerp below or animation
                        }
                        // INITIALIZE FLIGHT with DELAY (Birth from Light)
                        if (!this.isFlying && this.flightProgress === 0 && this.flightDelay === 0) {
                            // è®¾å®šèµ·é£å»¶è¿Ÿï¼Œç­‰å¾…ç™½å…‰ç¨å¾®æ¶ˆæ•£
                            this.flightDelay = 0.5; // 0.5ç§’å»¶è¿Ÿ
                            
                            this.isFlying = true;
                            // å°†åˆå§‹ä½ç½®è®¾ç½®ä¸ºå½“å‰çˆ†ç‚¸ä¸­å¿ƒé™„è¿‘ï¼Œæ¨¡æ‹Ÿè¯ç”Ÿ
                            this.flightStartPos.copy(STATE.explosion.center).add(
                                new THREE.Vector3(
                                    (Math.random()-0.5)*2,
                                    (Math.random()-0.5)*2,
                                    (Math.random()-0.5)*2
                                )
                            );
                            
                            this.mesh.position.copy(this.flightStartPos);
                            this.mesh.scale.setScalar(0.01); 
                            
                            const midPoint = new THREE.Vector3().addVectors(this.flightStartPos, finalTarget).multiplyScalar(0.5);
                            const randomOffset = new THREE.Vector3(
                                (Math.random() - 0.5) * 60, 
                                (Math.random() - 0.5) * 60, 
                                (Math.random() - 0.5) * 30   
                            );
                            this.flightControlPos.addVectors(midPoint, randomOffset);
                            this.flightDuration = 2.0; // æ”¾æ…¢é£è¡Œé€Ÿåº¦ï¼Œå¢åŠ ç¥åœ£æ„Ÿ
                        }
                        
                        if (this.isFlying) {
                            // å¤„ç†å»¶è¿Ÿ
                            if (this.flightDelay > 0) {
                                this.flightDelay -= dt;
                                this.mesh.position.copy(STATE.explosion.center); // ä¿æŒåœ¨ä¸­å¿ƒ
                                this.mesh.scale.setScalar(0.01);
                            } else {
                                this.flightProgress += dt / this.flightDuration;
                                if (this.flightProgress >= 1) this.flightProgress = 1;
                                const t = this.flightProgress;
                                const invT = 1 - t;
                                const p0 = this.flightStartPos;
                                const p1 = this.flightControlPos;
                                const p2 = finalTarget;
                                this.mesh.position.x = (invT * invT * p0.x) + (2 * invT * t * p1.x) + (t * t * p2.x);
                                this.mesh.position.y = (invT * invT * p0.y) + (2 * invT * t * p1.y) + (t * t * p2.y);
                                this.mesh.position.z = (invT * invT * p0.z) + (2 * invT * t * p1.z) + (t * t * p2.z);
                                
                                // Scale ease-out back (ä»å…‰ä¸­å˜å¤§)
                                const currentScale = 0.01 + (s - 0.01) * Math.pow(this.flightProgress, 0.5); // å¼€æ–¹ï¼Œå¿«é€Ÿå˜å¤§
                                this.mesh.scale.setScalar(currentScale);
                                
                                if (t < 0.9) {
                                    this.mesh.rotation.x += (10 * invT) * dt;
                                    this.mesh.rotation.y += (5 * invT) * dt;
                                    this.mesh.rotation.z += (8 * invT) * dt;
                                } 
                            }
                        } 
                        
                        if (this.flightProgress >= 1) {
                            this.mesh.position.copy(finalTarget);
                            this.mesh.scale.setScalar(s);
                            const targetLook = new THREE.Object3D();
                            targetLook.position.copy(this.mesh.position);
                            const localCamPos = camera.position.clone();
                            mainGroup.worldToLocal(localCamPos);
                            targetLook.lookAt(localCamPos);
                            this.mesh.quaternion.slerp(targetLook.quaternion, 10 * dt);
                        }
                        const frameMesh = this.mesh.children[0];
                        if (frameMesh && frameMesh.material) {
                            const pulse = (Math.sin(clock.elapsedTime * 10) * 0.5 + 0.5); 
                            frameMesh.material.emissiveIntensity = 1.0 + pulse * 2.5;
                        }
                    } else {
                        // FOCUS æ¨¡å¼ä¸‹ï¼Œæœªé€‰ä¸­çš„å¡ç‰‡/ç²’å­è¢«ç‚¸é£
                        applyLogoMotion();
                        
                        // å…³é”®ä¿®æ”¹ï¼šå¦‚æœå—åˆ°çˆ†ç‚¸å†²å‡»ï¼Œæš‚æ—¶ç¦ç”¨ lerp å›åŸä½
                        // åªæœ‰å½“çˆ†ç‚¸å½±å“åŠ›å‡å¼±åï¼Œæ‰å¼€å§‹æ…¢æ…¢é£˜å›
                        if (explosionInfluence < 1.0) {
                            this.mesh.position.lerp(this.currentTarget, 2.0 * dt);
                        }
                        
                        let targetScale = s;
                        if (this.type === 'STRIP') targetScale = 0; // æœªé€‰ä¸­å¡ç‰‡éšè—
                        
                        this.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 3*dt);
                    }
                } else {
                    // LOGO MODE
                    applyLogoMotion();
                    
                    // åŒæ ·ï¼Œå¦‚æœæœ‰æ®‹ä½™é€Ÿåº¦ï¼Œå‡å¼± lerp
                    if (explosionInfluence < 1.0) {
                         this.mesh.position.lerp(this.currentTarget, 2.0 * dt);
                    }
                   
                    // ä¿®æ­£ï¼šLOGO æ¨¡å¼ä¸‹ï¼Œå¡ç‰‡éšè— (Scale -> 0)
                    let targetScale = s;
                    if (this.type === 'STRIP') targetScale = 0; 
                    
                    this.mesh.scale.lerp(new THREE.Vector3(targetScale,targetScale,targetScale), 3*dt);
                    
                    // Reset emissive
                     if (this.type === 'STRIP' && this.mesh.children[0]) {
                        this.mesh.children[0].material.emissiveIntensity = 0.5;
                    }
                }
                // --- ç¢°æ’æ£€æµ‹é€»è¾‘ (Collision Detection) ---
                // ä»…åœ¨ LOGO æ¨¡å¼æˆ– SCATTER æ¨¡å¼ä¸‹æ£€æµ‹ï¼Œé¿å…å¹²æ‰°æŠ½å¡åŠ¨ç”»
                if ((mode === 'LOGO' || mode === 'SCATTER') && activeMeteorsLocal && activeMeteorsLocal.length > 0) {
                    const impactRadius = 12.0; // æ’å‡»èŒƒå›´
                    const impactRadiusSq = impactRadius * impactRadius;
                    const repulsionStrength = 3.5; // æ’å‡»åŠ›åº¦
                    for (let i = 0; i < activeMeteorsLocal.length; i++) {
                        const meteorPos = activeMeteorsLocal[i];
                        // å¿«é€Ÿè·ç¦»æ£€æµ‹
                        const distSq = this.mesh.position.distanceToSquared(meteorPos);
                        
                        if (distSq < impactRadiusSq) {
                            const dist = Math.sqrt(distSq);
                            // è®¡ç®—æ–¥åŠ›å‘é‡ï¼šä»æµæ˜ŸæŒ‡å‘ç²’å­
                            const pushDir = this.mesh.position.clone().sub(meteorPos).normalize();
                            
                            // è·ç¦»è¶Šè¿‘ï¼Œæ–¥åŠ›è¶Šå¤§
                            // å¢åŠ ä¸€ä¸ªéšæœºæ‰°åŠ¨ï¼Œè®©ç‚¸å¼€çš„æ•ˆæœæ›´è‡ªç„¶
                            const force = (1 - dist / impactRadius) * repulsionStrength * (0.8 + Math.random() * 0.4);
                            
                            // ç›´æ¥ä¿®æ”¹ç²’å­ä½ç½®ï¼ˆç¬é—´æ¨å¼€ï¼‰
                            // ä¸‹ä¸€å¸§çš„ lerp ä¼šè´Ÿè´£æŠŠå®ƒæ‹‰å›æ¥ï¼Œå½¢æˆå¼¹ç°§æ•ˆæœ
                            this.mesh.position.add(pushDir.multiplyScalar(force));
                        }
                    }
                }
            }
        }
        // --- CREATION ---
        function createParticles() {
            const geoRock = new THREE.IcosahedronGeometry(0.25, 0); 
            const geoTech = new THREE.TetrahedronGeometry(0.25, 0);
            
            const matText = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.textEnergy,
                roughness: 0.4,
                metalness: 0.8,
                flatShading: true,
                emissive: 0xffffff,
                emissiveIntensity: 1.2
            });
            const matBlue = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.rockBlue,
                roughness: 0.4,
                metalness: 0.8,
                flatShading: true,
                emissive: 0x002288,
                emissiveIntensity: 0.4
            });
            for (let i = 0; i < CONFIG.particles.count; i++) {
                let targetPoint = (logoPoints.length > 0) ? logoPoints[i % logoPoints.length] : {x:0, y:0, z:0, type:'BLUE'};
                let mesh;
                
                if (targetPoint.type === 'TEXT') {
                    mesh = new THREE.Mesh(geoTech, matText); 
                    mesh.scale.setScalar(0.5 + Math.random() * 0.3); 
                } else {
                    const rand = Math.random();
                    if (rand > 0.6) {
                        mesh = new THREE.Mesh(geoTech, matBlue);
                    } else {
                        mesh = new THREE.Mesh(geoRock, matBlue);
                    }
                    mesh.scale.setScalar(0.5 + Math.random() * 0.6);
                }
                
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, targetPoint));
            }
            mainGroup.add(stripMeshGroup);
        }
        function createDust() {
            const geo = new THREE.TetrahedronGeometry(0.08, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.4 });
            
            for(let i=0; i<CONFIG.particles.dustCount; i++) {
                 const mesh = new THREE.Mesh(geo, mat);
                 mesh.scale.setScalar(0.5 + Math.random());
                 
                 const r = 40 + Math.random() * 50; 
                 const theta = Math.random() * Math.PI * 2;
                 const phi = Math.acos(2 * Math.random() - 1);
                 mesh.position.set(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                  );
                 
                 mainGroup.add(mesh);
            }
        }
        function createStripTexture(text, signature) {
            const width = 512; const height = 768; 
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // --- NEW COLOR THEME: DEEP BLUE COSMIC ---
            const grad = ctx.createLinearGradient(0, 0, width, height);
            grad.addColorStop(0, '#001529');   // Deep Midnight
            grad.addColorStop(0.5, '#002b4d'); // Dark Cosmic Blue
            grad.addColorStop(1, '#000f1f');   // Near Black
            ctx.fillStyle = grad; ctx.fillRect(0, 0, width, height);
            
            // --- NEW ACCENTS: CYAN/STARDUST ---
            ctx.fillStyle = 'rgba(75, 156, 211, 0.15)'; // Logo Blue faint
            for(let i=0; i<300; i++) ctx.fillRect(Math.random()*width, Math.random()*height, 3, 3);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; // White stars
            for(let i=0; i<50; i++) ctx.fillRect(Math.random()*width, Math.random()*height, 2, 2);
            // --- NEW BORDER: ELECTRIC BLUE ---
            ctx.strokeStyle = '#4B9CD3'; // Logo Blue
            ctx.lineWidth = 20; ctx.lineJoin = "round";
            ctx.strokeRect(20, 20, width - 40, height - 40);
            ctx.lineWidth = 4; 
            ctx.strokeStyle = '#88CCFF'; // Lighter blue inner line
            ctx.strokeRect(35, 35, width - 70, height - 70);
            // --- TEXT RENDERING IMPROVEMENT ---
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            // 1. Increase Font Size & Weight
            const fontSize = 52; 
            ctx.font = `900 ${fontSize}px "Microsoft YaHei", "SimHei", sans-serif`;
            
            const maxLineWidth = width - 120;
            const words = text.split('');
            let line = ''; let lines = [];
            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n];
                let metrics = ctx.measureText(testLine);
                if (metrics.width > maxLineWidth && n > 0) { lines.push(line); line = words[n]; }
                else { line = testLine; }
            }
            lines.push(line);
            const lineHeight = fontSize * 1.5;
            const totalTextHeight = lines.length * lineHeight;
            let startY = (height / 2) - (totalTextHeight / 2) - 40; 
            
            // 2. Multi-pass Text Drawing (Outline + Sharp Fill + Hard Shadow)
            // UPDATED: Removed glow, added hard black shadow and outline for clarity in bloom
            for (let i = 0; i < lines.length; i++) {
                const y = startY + (i * lineHeight);
                const x = width / 2;
                // Pass 1: Strong Black Outline (Foundation)
                ctx.lineWidth = 10; // å¢åŠ æè¾¹å®½åº¦ï¼Œæé«˜å¯¹æ¯”åº¦
                ctx.strokeStyle = "rgba(0, 0, 0, 1.0)"; // çº¯é»‘ä¸é€æ˜
                ctx.lineJoin = 'round';
                ctx.strokeText(lines[i], x, y);
                // Pass 2: Subtle Dark Shadow (Depth)
                ctx.shadowColor = "rgba(0, 0, 0, 1.0)";
                ctx.shadowBlur = 0; // ç§»é™¤æ¨¡ç³Šï¼Œä¿æŒé”åˆ©
                ctx.shadowOffsetX = 4; // ç¨å¾®å¢åŠ æŠ•å½±è·ç¦»
                ctx.shadowOffsetY = 4;
                
                // Pass 3: Text Body
                // å…³é”®ä¿®æ”¹ï¼šé™ä½å¡«å……é¢œè‰²çš„äº®åº¦ã€‚
                // åœ¨ Bloom å¼€å¯çš„æƒ…å†µä¸‹ï¼Œäº®åº¦é«˜çš„é¢œè‰²ä¼šäº§ç”Ÿå¼ºçƒˆçš„è¾‰å…‰å¯¼è‡´è¾¹ç¼˜æ¨¡ç³Šã€‚
                // ä½¿ç”¨ä¸­ç°/ç°è“è‰² (#99AACC) åœ¨ Bloom åå¤„ç†ä¸‹ä¼šå‘ˆç°å‡ºâ€œæ¸…æ™°çš„å¾®å‘å…‰ç™½è‰²/æµ…è“â€æ•ˆæœï¼Œè€Œä¸æ˜¯â€œåˆºçœ¼çš„ç™½å…‰â€ã€‚
                ctx.fillStyle = "#99AACC"; 
                ctx.fillText(lines[i], x, y);
                // Reset shadow for next operations
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
            
            if (signature) {
                const sigX = width - 120; const sigY = height - 100;
                ctx.save(); ctx.translate(sigX, sigY); ctx.rotate(-0.1); 
                
                // Signature Background
                ctx.fillStyle = 'rgba(0, 20, 40, 0.8)'; 
                ctx.fillRect(-60, -40, 120, 80);
                
                // Signature Border
                ctx.strokeStyle = 'rgba(75, 156, 211, 0.6)'; 
                ctx.lineWidth = 3; 
                ctx.strokeRect(-55, -35, 110, 70);
                
                // Signature Text
                ctx.font = 'bold 24px "Microsoft YaHei"'; 
                ctx.fillStyle = '#88AACC'; // Darker Light Blue
                ctx.shadowBlur = 0;
                ctx.fillText(signature, 0, 5); 
                ctx.restore();
            }
            
            // Decorative symbols
            ctx.font = '40px serif'; ctx.fillStyle = '#4B9CD3';
            ctx.fillText("   âœ¦   ", width / 2, 80); ctx.fillText("   âœ¦   ", width / 2, height - 40);
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }
        function addStripToScene(texture, dbId) {
            const width = 2.2; const height = 3.3; 
            const frameGeo = new THREE.BoxGeometry(width + 0.1, height + 0.1, 0.1); 
            
            // --- NEW FRAME MATERIAL ---
            const frameMat = new THREE.MeshPhysicalMaterial({ 
                color: CONFIG.colors.cardFrame, // Logo Blue
                metalness: 1.0, 
                roughness: 0.1, 
                transparent: true, 
                opacity: 0.9,
                emissive: CONFIG.colors.cardFrameEmissive,
                emissiveIntensity: 0.5 
            });
            
            const frame = new THREE.Mesh(frameGeo, frameMat);
            const paperGeo = new THREE.PlaneGeometry(width, height);
            // ä¿®æ­£ï¼šç¡®ä¿çº¸å¼ æè´¨æ”¯æŒé€æ˜åº¦ï¼Œä»¥ä¾¿æ·¡å‡º
            const paperMat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true, // å…³é”®ï¼šå…è®¸é€æ˜
                opacity: 1.0 
            });
            const paper = new THREE.Mesh(paperGeo, paperMat);
            paper.position.z = 0.051; 
            const group = new THREE.Group();
            group.add(frame); group.add(paper);
            
            const r = 35;
            const theta = Math.random() * Math.PI * 2; const phi = Math.random() * Math.PI;
            group.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            
            // ä¿®æ­£ï¼šåˆå§‹åŒ–æ—¶ä¸è®¾ä¸º0ï¼Œæˆ–è€…è®¾ä¸º1ï¼Œè¿™æ · baseScale è¯»å–æ­£ç¡®ã€‚
            // ä½†ä¸ºäº†é˜²æ­¢ä¸€å¼€å§‹é—ªç°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œè®¾ä¸º 1ï¼Œç„¶åä¾é  update å¾ªç¯åœ¨ç¬¬ä¸€å¸§å°†å…¶å˜ä¸º 0 (å¦‚æœåˆå§‹æ˜¯ LOGO æ¨¡å¼)
            // ä¸è¿‡ Particle æ„é€ å‡½æ•°é‡Œæˆ‘ä»¬ä¼šè¯»å– mesh.scale.xã€‚æ‰€ä»¥è¿™é‡Œè®¾ä¸º 1ã€‚
            group.scale.set(1,1,1); 
            
            stripMeshGroup.add(group);
            
            // åˆ›å»ºç²’å­åï¼Œç«‹å³æ‰‹åŠ¨è®¾å› 0ï¼Œé˜²æ­¢ç¬¬ä¸€å¸§é—ªçƒï¼Œç­‰å¾… update é€»è¾‘æ¥ç®¡
            const p = new Particle(group, {x:0, y:0, z:0, type:'STRIP', dbId: dbId});
            group.scale.set(0,0,0); 
            
            particleSystem.push(p); 
        }
        async function initMediaPipe() {
            video = document.getElementById('webcam');
            webcamCanvas = document.getElementById('webcam-preview');
            webcamCtx = webcamCanvas.getContext('2d');
            webcamCanvas.width = 160; webcamCanvas.height = 120;
            
            try {
                // å°è¯•åˆå§‹åŒ– MediaPipe
                console.log('æ­£åœ¨åŠ è½½ MediaPipe æ‰‹åŠ¿è¯†åˆ«...');
                
                const visionUrls = [
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm",
                    "https://unpkg.com/@mediapipe/tasks-vision@0.10.3/wasm", // å¤‡é€‰
                ];
                
                const modelUrls = [
                    "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/hand_landmarker.task" // å¤‡é€‰
                ];
                
                let vision = null;
                for (let url of visionUrls) {
                    try {
                        vision = await FilesetResolver.forVisionTasks(url);
                        console.log('  âœ“   Vision tasks åŠ è½½æˆåŠŸ:', url);
                        break;
                    } catch(e) {
                        console.warn('  âœ—   Vision tasks åŠ è½½å¤±è´¥:', url, e);
                    }
                }
                
                if (!vision) {
                    throw new Error('æ— æ³•åŠ è½½ MediaPipe Vision Tasks');
                }
                
                let modelPath = null;
                for (let url of modelUrls) {
                    try {
                        // å¿«é€Ÿæµ‹è¯• URL æ˜¯å¦å¯ç”¨
                        const response = await fetch(url, { method: 'HEAD' });
                        if (response.ok) {
                            modelPath = url;
                            console.log('  âœ“   æ‰‹åŠ¿æ¨¡å‹å¯ç”¨:', url);
                            break;
                        }
                    } catch(e) {
                        console.warn('  âœ—   æ‰‹åŠ¿æ¨¡å‹ä¸å¯ç”¨:', url);
                    }
                }
                
                if (!modelPath) {
                    throw new Error('æ— æ³•åŠ è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹');
                }
                
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { 
                        modelAssetPath: modelPath, 
                        delegate: "GPU" 
                    },
                    runningMode: "VIDEO", 
                    numHands: 1,
                    minHandDetectionConfidence: 0.3, 
                    minHandPresenceConfidence: 0.3, 
                    minTrackingConfidence: 0.3
                });
                
                console.log('  âœ“   MediaPipe æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–æˆåŠŸ');
                
            } catch(error) {
                console.error('  âŒ   MediaPipe åˆå§‹åŒ–å¤±è´¥:', error);
                // é™çº§å¤„ç†ï¼šæ˜¾ç¤ºç¦»çº¿æç¤º
                updateHint('  âš   ï¸ æ‰‹åŠ¿è¯†åˆ«æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                handLandmarker = null;
            }
            
            // å°è¯•å¯ç”¨æ‘„åƒå¤´
            if (navigator.mediaDevices?.getUserMedia) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        } 
                    });
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictWebcam);
                    console.log('  âœ“   æ‘„åƒå¤´å·²å¯ç”¨');
                } catch(error) {
                    console.warn('  âš   ï¸ æ‘„åƒå¤´è®¿é—®å¤±è´¥:', error);
                    updateHint('  âš   ï¸ æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
                }
            }
        }
        let lastVideoTime = -1;
        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, performance.now());
                    processGestures(result);
                }
            }
            requestAnimationFrame(predictWebcam);
        }
        // --- Helper for UI Hint Updates ---
        const hintEl = document.querySelector('.bottom-hint');
        function updateHint(msg) {
            if (hintEl.innerHTML !== msg) {
                hintEl.innerHTML = msg;
                hintEl.style.color = "#fff"; // Flash white
                setTimeout(() => hintEl.style.color = "rgba(200, 230, 255, 0.8)", 300);
            }
        }
        function processGestures(result) {
            webcamCtx.clearRect(0, 0, webcamCanvas.width, webcamCanvas.height);
            if (result.landmarks && result.landmarks.length > 0) {
                STATE.hand.detected = true;
                const lm = result.landmarks[0];
                drawHandSkeleton(webcamCtx, lm, 'rgba(0, 255, 255, 0.8)');
                STATE.hand.x = (lm[9].x - 0.5) * 2; STATE.hand.y = (lm[9].y - 0.5) * 2;
                const thumb = lm[4]; const index = lm[8]; const wrist = lm[0];
                const middle = lm[12]; const ring = lm[16]; const pinky = lm[20];
                
                const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
                
                // è®¡ç®—æ¯ä¸ªæŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
                const dIndex = Math.hypot(index.x - wrist.x, index.y - wrist.y);
                const dMiddle = Math.hypot(middle.x - wrist.x, middle.y - wrist.y);
                const dRing = Math.hypot(ring.x - wrist.x, ring.y - wrist.y);
                const dPinky = Math.hypot(pinky.x - wrist.x, pinky.y - wrist.y);
                
                // 1. ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡çš„å¹³å‡ä¼¸å±•ç¨‹åº¦
                const otherFingersAvg = (dMiddle + dRing + dPinky) / 3;
                
                // 2. æ‰€æœ‰æ‰‹æŒ‡çš„å¹³å‡ä¼¸å±•ç¨‹åº¦ (ç”¨äºæ¡æ‹³æ£€æµ‹)
                const allFingersAvg = (dIndex + dMiddle + dRing + dPinky) / 4;
                
                // 3. è¾…åŠ©åˆ¤æ–­ï¼šä¸­æŒ‡æ˜¯å¦ç‹¬ç«‹ä¼¸ç›´ (é¿å…OKæ‰‹åŠ¿è¢«è¯†åˆ«ä¸ºåŠæ¡æ‹³)
                const isMiddleStraight = dMiddle > 0.35;
                
                // --- é€»è¾‘åˆ¤æ–­ä¼˜åŒ– ---
                
                // 1. æ¡æ‹³æ£€æµ‹ (Reset) - ä¼˜å…ˆçº§æœ€é«˜
                // æ”¾å®½äº†é˜ˆå€¼ (0.3)ï¼Œåªè¦å¤§éƒ¨åˆ†æ‰‹æŒ‡å¼¯æ›²å°±ç®—æ¡æ‹³ï¼Œé˜²æ­¢â€œåŠæ¡â€è¢«å¿½ç•¥
                // å¢åŠ äº† !isMiddleStraight æ¡ä»¶ï¼Œé˜²æ­¢æ€ªå¼‚æ‰‹åŠ¿è¯¯åˆ¤
                if (allFingersAvg < 0.3) {
                    
                    // --- ç²’å­è§£ä½“é€»è¾‘ä¿æŒä¸å˜ ---
                    if (STATE.mode === 'FOCUS' && STATE.focusTarget) {
                        const targetP = particleSystem.find(p => p.mesh === STATE.focusTarget);
                        if (targetP) {
                            const explodePos = STATE.focusTarget.position.clone();
                            targetP.dissolve();
                            setTimeout(() => {
                                debrisSystem.explode(explodePos);
                            }, 100); 
                        }
                    }
                    STATE.mode = 'LOGO'; STATE.focusTarget = null; 
                    STATE.readyToDraw = false; 
                    updateHint("æ‰‹åŠ¿: æ¡æ‹³é‡ç½® | è¯·å…ˆå¼ å¼€æ‰‹æŒæ¿€æ´»æ˜Ÿé˜µ");
                    drawHandSkeleton(webcamCtx, lm, 'rgba(255, 50, 50, 0.9)');
                    return; 
                }
                
                // 2. OKæ‰‹åŠ¿æ£€æµ‹ (Draw) - å¿…é¡»å…ˆæ¿€æ´»
                // æ ¸å¿ƒä¿®æ”¹ï¼šotherFingersAvg > 0.4 (åŸ0.25)ï¼Œå¼ºåˆ¶è¦æ±‚å…¶ä»–ä¸‰æŒ‡ä¼¸ç›´
                if (pinchDist < 0.08 && otherFingersAvg > 0.4) {
                    if (STATE.readyToDraw) {
                        // å·²ç»å¼ æ‰‹æ¿€æ´»è¿‡ï¼Œå…è®¸æŠ½å–
                        drawHandSkeleton(webcamCtx, lm, 'rgba(75, 156, 211, 0.9)'); // Blue highlight
                        drawOkHighlight(webcamCtx, thumb, index, [middle, ring, pinky]);
                        updateHint("   âœ¨    è¶…æ–°æ˜Ÿèƒ½é‡é‡Šæ”¾!    âœ¨   ");
                        
                        if (!STATE.focusTarget) {
                            const candidates = particleSystem.filter(p => {
                                if (p.type !== 'STRIP') return false;
                                const card = fortuneDatabase.find(c => c.id === p.dbId);
                                return card && !card.isDrawn;
                            });
                            
                            if (candidates.length > 0) {
                                const selectedParticle = candidates[Math.floor(Math.random() * candidates.length)];
                                selectedParticle.isDrawn = true;
                                const card = fortuneDatabase.find(c => c.id === selectedParticle.dbId);
                                if(card) card.isDrawn = true;
                                STATE.focusTarget = selectedParticle.mesh;
                                STATE.mode = 'FOCUS'; 
                                
                                // --- TRIGGER SUPERNOVA ---
                                triggerSupernova(selectedParticle.mesh.position.clone());
                            }
                        }
                    } else {
                        // æœªæ¿€æ´»ï¼Œæç¤ºç”¨æˆ·
                        updateHint("   âš    ï¸ è¯·å…ˆå¼ å¼€æ‰‹æŒï¼Œæ¿€æ´»æ˜Ÿé˜µèƒ½é‡");
                        drawHandSkeleton(webcamCtx, lm, 'rgba(100, 100, 100, 0.5)'); // ç°è‰²æç¤ºæœªæ¿€æ´»
                    }
                } 
                // 3. å¼ å¼€æ‰‹æŒæ£€æµ‹ (Activate / Scatter)
                // ç¨å¾®æé«˜å¼ æ‰‹é˜ˆå€¼ (0.4)ï¼Œé¿å…åœ¨â€œæ¾æ•£çš„OKæ‰‹åŠ¿â€å’Œâ€œå¼ æ‰‹â€ä¹‹é—´è·³å˜
                else if (allFingersAvg > 0.4 && pinchDist > 0.1) {
                    if (STATE.mode !== 'FOCUS') { 
                        STATE.mode = 'SCATTER'; STATE.focusTarget = null; 
                        STATE.readyToDraw = true; // æ¿€æ´»ï¼
                        updateHint("   ğŸŒŸ    èƒ½é‡å·²æ¿€æ´»! è¯·æ¯” OK æ‰‹åŠ¿æŠ½å–    ğŸŒŸ   ");
                    }
                }
            } else { 
                STATE.hand.detected = false;
                webcamCtx.fillStyle = "rgba(255, 255, 255, 0.5)"; webcamCtx.font = "12px Arial"; webcamCtx.textAlign = "center";
                webcamCtx.save(); webcamCtx.translate(webcamCanvas.width, 0); webcamCtx.scale(-1, 1);
                webcamCtx.fillText("å¯»æ‰¾æ‰‹åŠ¿...", webcamCanvas.width / 2, webcamCanvas.height / 2);
                webcamCtx.restore();
            }
        }
        
        // --- SUPERNOVA LOGIC ---
        function triggerSupernova(center) {
            STATE.explosion.active = true;
            STATE.explosion.triggerTime = clock.getElapsedTime();
            STATE.explosion.center.copy(center);
            
            // 1. è§¦å‘ç›¸æœºéœ‡åŠ¨
            STATE.shake = 1.5; // è®¾ç½®åˆå§‹éœ‡åŠ¨å¼ºåº¦
            // 2. Visual Overload (Global Exposure Flash)
            // æ¢å¤å…¨å±å¼ºå…‰è¿‡è½½
            renderer.toneMappingExposure = 8.0; 
            
            // 3. Physics Blast
            // éå†æ‰€æœ‰ç²’å­ï¼Œæ–½åŠ å¾„å‘æ–¥åŠ›
            particleSystem.forEach(p => {
                // è·³è¿‡é€‰ä¸­çš„å¡ç‰‡ (å®ƒåœ¨ Particle.update é‡Œä¼šç‰¹æ®Šå¤„ç†)
                if (p.mesh === STATE.focusTarget) return;
                
                const dir = new THREE.Vector3().subVectors(p.mesh.position, center);
                let dist = dir.length();
                if (dist < 0.1) dist = 0.1; // é¿å…é™¤é›¶
                
                dir.normalize();
                
                // è·ç¦»è¶Šè¿‘ï¼Œæ–¥åŠ›è¶Šå¤§ã€‚
                // åŸºç¡€åŠ›åº¦å¾ˆå¤§ï¼Œæ¨¡æ‹Ÿç¬é—´çˆ†ç‚¸
                const force = 800.0 / (dist * 0.5 + 1.0); 
                
                // ç»™ç²’å­æ–½åŠ ç¬é—´é€Ÿåº¦
                p.explosionVelocity.add(dir.multiplyScalar(force));
            });
        }
        function drawHandSkeleton(ctx, landmarks, color) {
            const w = ctx.canvas.width; const h = ctx.canvas.height;
            const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17],[0,17]];
            ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = color; 
            ctx.beginPath(); connections.forEach(([i, j]) => { ctx.moveTo(landmarks[i].x * w, landmarks[i].y * h); ctx.lineTo(landmarks[j].x * w, landmarks[j].y * h); }); ctx.stroke();
            ctx.fillStyle = '#ffffff'; landmarks.forEach(p => { ctx.beginPath(); ctx.arc(p.x * w, p.y * h, 2, 0, 2 * Math.PI); ctx.fill(); });
        }
        function drawOkHighlight(ctx, thumb, index, otherTips) {
            const w = ctx.canvas.width; const h = ctx.canvas.height;
            const cx = (thumb.x + index.x) / 2 * w; const cy = (thumb.y + index.y) / 2 * h;
            const gradient = ctx.createRadialGradient(cx, cy, 5, cx, cy, 20);
            gradient.addColorStop(0, 'rgba(75, 156, 211, 0.8)'); gradient.addColorStop(1, 'rgba(75, 156, 211, 0)');
            ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(cx, cy, 20, 0, 2 * Math.PI); ctx.fill();
            ctx.strokeStyle = '#4B9CD3'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(thumb.x * w, thumb.y * h); ctx.lineTo(index.x * w, index.y * h); ctx.stroke();
            ctx.fillStyle = '#4B9CD3'; otherTips.forEach(tip => { ctx.beginPath(); ctx.arc(tip.x * w, tip.y * h, 4, 0, 2 * Math.PI); ctx.fill(); });
        }
        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const elapsed = clock.getElapsedTime(); // è·å–æ€»è¿è¡Œæ—¶é—´
            // æ›´æ–°æ˜Ÿæ˜Ÿé—ªçƒæ—¶é—´
            if (starUniforms) {
                starUniforms.uTime.value = elapsed;
            }
            // æ›´æ–°ç¢ç‰‡ç³»ç»Ÿ
            if(debrisSystem) debrisSystem.update(dt);
            // --- Camera Shake Logic (æ–°å¢) ---
            if (STATE.shake > 0) {
                // äº§ç”Ÿéšæœºéœ‡åŠ¨ä½ç§»
                const rx = (Math.random() - 0.5) * STATE.shake;
                const ry = (Math.random() - 0.5) * STATE.shake * 0.5; // Yè½´éœ‡åŠ¨ç¨å¾®å°ä¸€ç‚¹
                
                camera.position.x = rx;
                camera.position.y = ry;
                
                // éœ‡åŠ¨è¡°å‡
                STATE.shake -= dt * 3.0;
                if (STATE.shake < 0) {
                    STATE.shake = 0;
                    camera.position.set(0, 0, CONFIG.camera.z); // å¤ä½
                }
            } else {
                // ç¡®ä¿ç›¸æœºä½ç½®å®Œå…¨å¤ä½
                if (camera.position.x !== 0 || camera.position.y !== 0) {
                     camera.position.set(0, 0, CONFIG.camera.z);
                }
            }
            // --- Exposure Decay Animation (Flash recovery) ---
            if (renderer.toneMappingExposure > 1.0) {
                // æŒ‡æ•°è¡°å‡ï¼Œå¹³æ»‘æ¢å¤åˆ°æ­£å¸¸æ›å…‰
                renderer.toneMappingExposure = THREE.MathUtils.lerp(renderer.toneMappingExposure, 1.0, 5.0 * dt);
            }
            if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
                const targetRotY = STATE.hand.x * Math.PI * 0.9; const targetRotX = STATE.hand.y * Math.PI * 0.25;
                STATE.rotation.y += (targetRotY - STATE.rotation.y) * 3.0 * dt; STATE.rotation.x += (targetRotX - STATE.rotation.x) * 3.0 * dt;
            } else {
                 // UPDATED: Allow rotation in both LOGO and FOCUS modes
                 // This keeps the background alive while reading the card
                 STATE.rotation.y += 0.04 * dt; 
                 STATE.rotation.x = Math.sin(clock.elapsedTime * 0.3) * 0.05;
            }
            
            mainGroup.rotation.y = STATE.rotation.y; mainGroup.rotation.x = STATE.rotation.x;
            mainGroup.updateMatrixWorld();
            
            // --- å…³é”®ï¼šé¢„è®¡ç®—æµæ˜Ÿåœ¨ mainGroup å±€éƒ¨åæ ‡ç³»ä¸­çš„ä½ç½® ---
            // è¿™æ ·ä¸ç”¨å¯¹ 8000 ä¸ªç²’å­æ¯ä¸ªéƒ½åšä¸€æ¬¡çŸ©é˜µæ±‚é€†
            let activeMeteorsLocal = [];
            if (meteors.length > 0) {
                // è®¡ç®— mainGroup çš„é€†çŸ©é˜µ
                const invWorldMatrix = mainGroup.matrixWorld.clone().invert();
                
                meteors.forEach(m => {
                    if (m.active) {
                        // å°†æµæ˜Ÿçš„ä¸–ç•Œåæ ‡è½¬æ¢ä¸º mainGroup çš„å±€éƒ¨åæ ‡
                        // åªéœ€è¦æ£€æµ‹é è¿‘ä¸­å¿ƒçš„æµæ˜Ÿï¼Œä¼˜åŒ–æ€§èƒ½
                        if (m.mesh.position.z > -150 && m.mesh.position.z < 150) {
                            const localPos = m.mesh.position.clone().applyMatrix4(invWorldMatrix);
                            activeMeteorsLocal.push(localPos);
                        }
                    }
                });
            }
            // Particles
            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget, activeMeteorsLocal));
            
            // Meteors update
            meteors.forEach(m => m.update(dt));
            // æ–°å¢ï¼šé“¶æ²³æ ¸å¿ƒåŠ¨ç”»é€»è¾‘
            if (galaxyCore) {
                // å¦‚æœæ˜¯ Logo æ¨¡å¼ï¼Œæ ¸å¿ƒæ¶ˆå¤±(opacity -> 0)ï¼›å¦‚æœæ˜¯ Scatter æˆ– Focus æ¨¡å¼ï¼Œæ ¸å¿ƒæ˜¾ç°
                // é™ä½ç›®æ ‡ä¸é€æ˜åº¦ï¼Œä» 0.9 -> 0.6ï¼Œè®©å®ƒæ›´åƒä¸€å›¢æ°”ä½“è€Œä¸æ˜¯å®ä½“
                const targetOpacity = (STATE.mode === 'LOGO') ? 0 : 0.6;
                
                // å¹³æ»‘è¿‡æ¸¡é€æ˜åº¦
                galaxyCore.material.opacity += (targetOpacity - galaxyCore.material.opacity) * 1.5 * dt;
                
                // æ·»åŠ å‘¼å¸æ•ˆæœ
                if (galaxyCore.material.opacity > 0.01) {
                    // å‡ç¼“å‘¼å¸é¢‘ç‡ï¼Œæ›´æ²‰ç¨³
                    const pulse = 1.0 + Math.sin(clock.elapsedTime * 0.8) * 0.1;
                    galaxyCore.scale.set(100 * pulse, 100 * pulse, 1);
                    // ç¼“æ…¢è‡ªè½¬æ•ˆæœ (Sprite æ€»æ˜¯é¢æœæ‘„åƒæœºï¼Œæ‰€ä»¥è¿™é‡Œç”¨ z è½´æ—‹è½¬æ¨¡æ‹Ÿå…‰æ™•æ—‹è½¬)
                    galaxyCore.material.rotation += 0.05 * dt; 
                }
            }
            composer.render();
        }
        init();
    </script>
</body>
</html>
